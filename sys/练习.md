# 第2章 进程的描述与控制

## 进程的基本概念

试画出下面三条语句的前趋图：

S1: a=5-x ; S2: b=a+x ; S3: c=4-x ;

S4: d=b+c ; S5: e=d+3 ;

**解:** 

![img](%E7%BB%83%E4%B9%A0.assets/clip_image002.png)



---

试利用 Bernstein 条件证明作业 1 中：

（1）S2 和 S3 语句是可以并发执行的，

（2）S3 和 S4 语句是不能并发执行的。

**解:**

R(S2) = a, x; W(S2) = b;

R(S3) = x; 	W(S3) = c;

R(S4) = b, c; W(S4) = d;

(1) R(S2) ∩ W(S3) = ϕ, R(S3) ∩ W(S2) = ϕ, 且 W(S2) ∩ W(S3) = ϕ, 所以 S1, S2 可并发

(2) R(S4) ∩ W(S3) != ϕ 所以 S3, S4 不可并发

---

某系统的进程转换图如图所示，请说明：

（1）引起各种状态状态转换的典型事件有哪些？

（2）当我们观察系统中某些进程时，能够看到某一进程产生的一次状态转换能引起另一进程作一次状态转换。在什么情况下，当一个进程发生转换 3 时能立即引起另一进程发生转换 1？试说明是否发生下述因果转换：2 导致 1；3 导致 2；4 导致1。

![image-20200502193307778](%E7%BB%83%E4%B9%A0.assets/image-20200502193307778.png)

**解:**

(1) 

- 就绪->执行: 时间片轮到了, 系统调度, 进程得到了处理机
- 执行->就绪: 时间片用完了, 挂起了, 被抢占了
- 执行->阻塞: 请求I/O, 请求的资源得不到
- 阻塞->就绪: I/O完成

(2)

- 3 导致 1: 一个程序阻塞, 就从就绪队列调一个进程执行
- 2 导致 1: 时间片到了, 正在执行的进程重新回到就绪队列, 并从就绪队列调一个进程执行, 如果就绪队列为空, 就执行刚转为就绪状态的进程
- 3 导致 2: 不能发生?想不到
- 4 导致 1: 进程获得资源后, 处理机空闲, 则进程被调度执行

---

在操作系统中为什么要引入进程概念，它会产生什么影响？

**解:** 

为了实现并发同时又要可再现. 程序的并发执行有不可再现性, 而进程有PCB可以恢复现场

引入进程可以提高系统资源利用率, 和系统吞吐量, 但需要的时空开销也越大, 包括进程的切换, 同步, 通信

---

试从动态性、并发性和独立性上比较进程和程序

**解:** 

- 动态性: 因创建而产生, 因调度而执行, 因得不到资源而暂停, 因撤销而灭亡
- 并发性: 多个进程在同一个时间段内能同时执行
- 独立性: 进程是资源拥有, 独立调度/分派的基本单位

---

试说明 PCB 的作用，为什么说 PCB 是进程存在的唯一标志？

**解:** 

作用: 

- 作为独立运行基本单位的标志: 是进程存在的唯一标志
- 能实现间断性运行方式: 保存和恢复现场
- 提供进程管理所需要的信息: 找到程序和数据
- 提供进程控制所需要的信息: PCB中有现行状态和优先级
- 实现与其他进程的同步和通信

因为系统通过PCB控制进程, PCB存在进程才存在



## 进程同步

设 P1,P2,P3,P4,P5,P6 为一组合作进程，其前趋图如图所示，用 P、V 操作实现其同步。

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200502212141008.png" alt="image-20200502212141008" style="zoom:80%;" />

**解:** 

```
main(){ P1(); P2(); P3(); P4(); P5(); P6();}
P1(){ P1; V(a); V(b); V(c); }
P2(){ P(c); P2; V(f); }
P3(){ P(b); P3; V(e); }
P4(){ P(a); P4; V(d); }
P5(){ P(f); P5; }
P6(){ P(d); P(e); P6; }
```



---

我们为某临界区设置一把锁 W，当 W=1 时，表示关锁；W=0 时，表示锁已打开。试写出开锁原语和关锁原语，并利用它们去实现互斥。

**解:** 

```c
procedure lock(){
    while(W) do no-op;
    W=1;
}

procedure unlock(){
    W=0;
}

main(){
    lock();
    resource();  // using resource
    unlock();
}
```



## 经典进程同步问题

在生产者－消费者问题中，如果缺少了 signal(full) 或 signal(empty)，对执行结果会有何影响?

**解:** 

- 如果缺少signal(full): 消费者不能进入取走产品, 生产者会一直生产直到货架满

- 如果缺少signal(empty): 如果货架能装n个产品, 那么生产者最多能生产n个产品, 然后即使消费者将产品消费完, 生产者也不能生产 (empty初始化为n)

---

在生产者－消费者问题中，如果将两个wait操作即wait(full)和wait(mutex)互换位置；或者是将 signal(mutex) 与 signal(full) 互换位置结果会如何?

**解:** 

- wait(full)和wait(mutex)互换: 有可能产生死锁, 当消费者占用货架资源, 却又因拿不到产品而阻塞时, 生产者也不能获取货架资源来放置产品
- signal(mutex) 与 signal(full) 互换: 没问题

---

在测量控制系统中的数据采集任务，把所采集的数据送一单缓冲区；计算任务从该单缓冲中取出数据进行计算。试写出利用信号量机制实现两者共享单缓冲的同步算法。

**解:** 

```c++
Semaphore mutex=1, empty=1, full=0;
// 将数据送到缓冲器
collect(){
    采集数据
    P(empty);
    P(mutex);  // 进入区
    将数据送入缓冲区
    V(mutex);  // 退出区
    V(full);
}

// 获得数据进行计算
compute(){
    P(full);
    P(mutex);  // 进入区
    从缓冲区取得数据
    V(mutex);  // 退出区
    V(empty);
    计算
}
```



---

试修改下面生产者－消费者问题解法中的错误：

**解:**

```
producer:
begin
	repeat
		producer an item in nextp ;
		wait (empty) ;
		wait (mutex) ;
		buffer (in):= nextp;
		in:=(in+1) mod n; 
		signal (mutex) ;
		signal (full) ;
	until false ;
end

consumer:
begin
	repeat
		wait (full) ;
		wait (mutex) ;
		nextc:= buffer (out) ;
		out:= (out+1) mod n;
		signal (mutex) ;
		signal (empty) ;
		consumer item in nextc ;
	until false ;
end
```

---

某数据库有多个写进程，多个读进程，它们之间读、写操作的互斥要求是：写进程正在写该数据库时不能有其他进程读数据库，也不能有其他进程写该数据库；读进程之间不互斥，可以同时读该数据库。请用信号量及P、V 操作描述这一组进程的工作过程。

**解:**

写写互斥, 读写互斥, 读读不互斥

```
int readCount = 0;  // 当前在读的进程数
semaphore rmutex=1;  // 读互斥信号量
semaphore wmutex=1;  // 写互斥信号量
semaphore s=1;  // 读写互斥信号量
Read(){
	P(s);
	P(rmutex);
	if(++readCount==1)  // 读比写先到
		P(wmutex);  // 阻止写
	V(rmutex);
	V(s);
	read database...
	P(rmutex);
	if(--readCount==0)  // 最后一个读的也走了
		V(wmutex);  // 允许写
	V(rmutex);
}

Write(){
	P(s);
	P(wmutex);
	write database...
	V(wmutex);
	V(s);
}
```



# 第3章 处理机调度与死锁

引起进程调度的因素有哪些？

**解:**

- 进程被阻塞
- 阻塞进程获得临界资源
- 进程执行完
- 进程被高优先级进程抢占
- 进程执行完一个时间片

---

某进程被唤醒后立即投入运行，我们就说这个系统采用的是抢占（剥夺）调度方法，对吗？为什么？

**解:**

对, 如果是非抢占, 进程被唤醒后应该加入就绪队列, 只有抢占才能强迫唤醒它的进程释放处理机

---

高级调度与低级调度的主要任务是什么? 为什么要引入中级调度?

**解:**

- 高级调度: 从外存后备队列中选择作业进入内存的就绪队列
- 低级调度: 保存处理机的现场信息, 按某种算法取进程, 再把处理机分配给进程
- 中级调度: 在内存和外存对换区之间按照给定的策略选择进程对换, 可以解决内存紧张问题, 提高内存的利用率和系统吞吐量

---

何谓死锁? 产生死锁的原因和必要条件是什么?

**解:**

- 死锁: 多个进程在运行过程中因争夺资源造成了Deadly-Embrace, 若无外力干预, 这些进程都将无法向前推进
- 产生原因
  - 竞争不可抢占资源, 如打印机
  - 竞争可消耗资源, 如消息
  - 进程间推进顺序不当引起死锁
- 必要条件
  - 互斥条件: 对所分配到的资源进行排它性使用
  - 请求和保持条件: 进程占有了一个资源, 同时又因为请求了一个得不到的资源而阻塞了, 但对自己占有的资源不释放
  - 不可剥夺条件: 进程如果获得了资源, 就只能由自己释放
  - 环路等待条件: 发生死锁时, 必然存在一个进程-资源的循环链

---

在银行家算法中，若出现下述资源分配情况，试问：

(1) 该状态是否安全？

(2) 若进程 P2 提出请求 Request（1，2，2，2）后，系统能否将资源分配给它？

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200503001745252.png" alt="image-20200503001745252" style="zoom:67%;" />

**解:**

(1)

| Process | Work | Need | Allocation | Work+Allocation | Finish |
| ------- | ---- | ---- | ---------- | --------------- | ------ |
| P0      | 1622 | 0012 | 0032       | 1654            | true   |
| P1      | 199A | 1750 | 1000       | 299A            | true   |
| P2      | 299A | 2356 | 1354       | 3CEE            | true   |
| P3      | 1654 | 0652 | 0332       | 1986            | true   |
| P4      | 1986 | 0656 | 0014       | 199A            | true   |

安全序列 {P0, P3, P4, P1, P2}, 系统安全

(2) P2: Need2=1354, Request2=1222, Available=1622

1. Request2 < Need2
2. Request2 < Available
3. 为P2试分配

| Process | Work | Need | Allocation | Work+Allocation | Finish |
| ------- | ---- | ---- | ---------- | --------------- | ------ |
| P2      | 0400 | 1134 | 2576       | 2976            | true   |
| P0      | 2976 | 0012 | 0032       | 29A8            | true   |
| P1      | 29A8 | 1750 | 1000       | 39A8            | true   |
| P3      | 39A8 | 0652 | 0332       | 3CDA            | true   |
| P4      | 3CDA | 0656 | 0014       | 3CEE            | true   |

安全序列 {P2, P0, P1, P3, P4}, 可以分配

---

5 个进程 P1,P2,P3,P4,P5，规定优先数越小，优先级越高，试描述在采用下述调度算法时各个进程运行过程，并计算进程平均周转时间。忽略进程的调度时间。

(1) 先来先服务调度算法；

(2）时间片轮转调度算法（时间片1ms）；

(3）非剥夺式优先级调度算法；

(4）剥夺式优先级调度算法。

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200503001815863.png" alt="image-20200503001815863" style="zoom:67%;" />

**解:**

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200503140252406.png" alt="image-20200503140252406" style="zoom:67%;" />

---

假定在单处理机条件下有下列要执行的作业：

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200503001833781.png" alt="image-20200503001833781" style="zoom:67%;" />

用执行时间表（如下表）描述在分别采用**先来先服务**和**非抢占式优先级调度算法**时作业的执行情况。

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200503001846691.png" alt="image-20200503001846691" style="zoom:67%;" />

**解:**

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200503135958981.png" alt="image-20200503135958981" style="zoom:67%;" />



# 第4, 5章 存储管理

某操作系统采用可变分区分配存储管理方法，用户区为 512K，且始址为0。若分配时采用分配空闲区低地址部分的方案，且初始时用户的 512K空间空闲，对下述申请序列：申请 300K，申请 100K，释放 300K，申请150K，申请 30K，申请 40K，申请 60K，释放 30K。回答：
（1）采用首次适应算法，空闲分区中有哪些空块（给出始址、大小）？
（2）采用最佳适应算法，空闲分区中有哪些空块（给出始址、大小）？
（3）如再申请 100K，针对（1）和（2）各有什么结果？

**解:**

(1) 首次适应算法

1. 申请 300K: 始址0使用300K, 始址300K空闲212K
2. 申请 100K: 始址0使用300K, 始址300K使用100K, 始址400K空闲112K
3. 释放 300K: 始址0空闲300K, 始址300K使用100K, 始址400K空闲112K
4. 申请150K: 始址0使用150K, 始址150K空闲150K, 始址300K使用100K, 始址400K空闲112K
5. 申请 30K: 始址0使用150K, 始址150K使用30K, 始址180K空闲120K, 始址300K使用100K, 始址400K空闲112K
6. 申请 40K: 始址0使用150K, 始址150K使用30K, 始址180K使用40K, 始址220K空闲80K, 始址300K使用100K, 始址400K空闲112K
7. 申请 60K: 始址0使用150K, 始址150K使用30K, 始址180K使用40K, 始址220K使用60K, 始址280K空闲20K, 始址300K使用100K, 始址400K空闲112K
8. 释放 30K: 始址0使用150K, **始址150K空闲30K**, 始址180K使用40K, 始址220K使用60K, **始址280K空闲20K**, 始址300K使用100K, **始址400K空闲112K**

<u>有3个空闲块: 始址150K空闲30K, 始址280K空闲20K, 始址400K空闲112K</u>

(2) 最佳适应算法

1. 申请 300K: 始址0使用300K, 始址300K空闲212K
2. 申请 100K: 始址0使用300K, 始址300K使用100K, 始址400K空闲112K
3. 释放 300K: 始址0空闲300K, 始址300K使用100K, 始址400K空闲112K
4. 申请150K: 始址0使用150K, 始址150K空闲150K, 始址300K使用100K, 始址400K空闲112K
5. 申请 30K: 始址0使用150K, 始址150K空闲150K, 始址300K使用100K, 始址400K使用30K, 始址430空闲82K
6. 申请 40K: 始址0使用150K, 始址150K空闲150K, 始址300K使用100K, 始址400K使用30K, 始址430使用40K, 始址470K空闲42K
7. 申请 60K: 始址0使用150K, 始址150K使用60K, 始址210K空闲90K, 始址300K使用100K, 始址400K使用30K, 始址430使用40K, 始址470K空闲42K
8. 释放 30K: 始址0使用150K, 始址150K使用60K, **始址210K空闲90K**, 始址300K使用100K, **始址400K空闲30K**, 始址430使用40K, **始址470K空闲42K**

<u>有3个空闲块: 始址210K空闲90K, 始址400K空闲30K, 始址470K空闲42K</u>

(3)首次适应算法的空闲块变为: 始址150K空闲30K, 始址280K空闲20K, 始址500K空闲12K

最佳适应算法将无法分配, 申请失败

---

设有一页式存储管理系统，向用户提供的逻辑地址空间最大为 64 页，每页 1024B，内存总共有 32 个存储块，试问逻辑地址至少应为多少位？内存空间有多大？

**解:**

64*1024 = 2^6 * 2^10 = 2^16, 所以页内地址10位, 逻辑地址至少16位

32*1024B = 32KB, 所以内存空间为32KB

---

在一个段式存储管理系统中，其段表如下所示，试求表中逻辑地址对应的物理地址是什么？

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200625195219856.png" alt="image-20200625195219856" style="zoom:67%;" /><img src="%E7%BB%83%E4%B9%A0.assets/image-20200625195237794.png" alt="image-20200625195237794" style="zoom:67%;" />

**解:**

- 段号0 段内地址430: 
  1. 0<4, 段号小于段表长度
  2. 430<500, 段内地址小于段长
  3. 物理地址是 210+430 = **640**
- 段号2 段内地址120: 
  1. 2<4, 段号小于段表长度
  2. 120>90, 段内地址大于段长, 发出越界中断信号

---

在一分页存储管理系统中，逻辑地址长度为 16 位，页面大小为 4096B，现有一逻辑地址为 2F6AH，且第 0、1、2 页依次存放在物理块 5、10、11中，问相应的物理地址为多少？

**解:** 

4096 = 1000H

2F6AH / 1000H = 2H......F6AH	存放在第2页, 块内偏移地址是F6A

11*1000H + F6AH = BF6AH	物理地址为BF6AH

---

假定系统为某进程分配了 3 个物理块，进程运行时的页面走向为7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1, 开始时 3 个物理块均为空，给出采用下列算法时页面置换情况，并计算出缺页率。
（1）最佳置换淘汰算法
（2）先进先出淘汰算法
（3）最近最久未使用淘汰算法

**解:** 

(1) 最佳置换淘汰算法

| 页面     | 7    | 0    | 1    | 2    | 0    | 3    | 0    | 4    | 2    | 3    | 0    | 3    | 2    | 1    | 2    | 0    | 1    | 7    | 0    | 1    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **块1**  | 7    | 7    | 7    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 7    | 7    | 7    |
| **块2**  |      | 0    | 0    | 0    | 0    | 0    | 0    | 4    | 4    | 4    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| **块3**  |      |      | 1    | 1    | 1    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 3    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| **缺页** | 缺   | 缺   | 缺   | 缺   |      | 缺   |      | 缺   |      |      | 缺   |      |      | 缺   |      |      |      | 缺   |      |      |

缺页率 = 9 / 20

(2)先进先出淘汰算法

| 页面     | 7    | 0    | 1    | 2     | 0    | 3     | 0     | 4     | 2    | 3     | 0    | 3    | 2     | 1     | 2    | 0     | 1    | 7     | 0    | 1    |
| -------- | ---- | ---- | ---- | ----- | ---- | ----- | ----- | ----- | ---- | ----- | ---- | ---- | ----- | ----- | ---- | ----- | ---- | ----- | ---- | ---- |
| **块1**  | 7    | 7    | 7    | **2** | 2    | 2     | 2     | **4** | 4    | 4     | 4    | 4    | 4     | **1** | 1    | 1     | 1    | 1     | 1    | 1    |
| **块2**  |      | 0    | 0    | 0     | 0    | **3** | 3     | 2     | 2    | **3** | 3    | 3    | 3     | 3     | 3    | **0** | 0    | 0     | 0    | 0    |
| **块3**  |      |      | 1    | 1     | 1    | 1     | **0** | 0     | 0    | 0     | 0    | 0    | **2** | 2     | 2    | 2     | 2    | **7** | 7    | 7    |
| **缺页** | 缺   | 缺   | 缺   | 缺    |      | 缺    | 缺    | 缺    |      | 缺    |      |      | 缺    | 缺    |      | 缺    |      | 缺    |      |      |

缺页率 = 12 / 20

(3)最近最久未使用淘汰算法

| 页面     | 7    | 0    | 1    | 2    | 0    | 3    | 0    | 4    | 2    | 3    | 0    | 3    | 2    | 1    | 2    | 0    | 1    | 7    | 0    | 1    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **块1**  | 7    | 7    | 7    | 2    | 2    | 2    | 2    | 4    | 4    | 4    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| **块2**  |      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 3    | 3    | 3    | 3    | 3    | 3    | 0    | 0    | 0    | 0    | 0    |
| **块3**  |      |      | 1    | 1    | 1    | 3    | 3    | 3    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 2    | 7    | 7    | 7    |
| **缺页** | 缺   | 缺   | 缺   | 缺   |      | 缺   |      | 缺   | 缺   | 缺   | 缺   |      |      | 缺   |      | 缺   |      | 缺   |      |      |

缺页率 =  12 / 20

---

设一个进程已分到 4 个块（M=4），其页表如下所示。当进程访问第 4 页时产生缺页中断，请分别采用 FIFO 算法、LRU 算法、NRU 算法（同时考虑访问位和修改位）决定将哪一个页淘汰。判断是否需要回写。设时间值越小表示越早（离当前越久）。

<img src="%E7%BB%83%E4%B9%A0.assets/image-20200625200039099.png" alt="image-20200625200039099" style="zoom:67%;" />

**解:** 

FIFO 算法: 将淘汰第3页, 无需回写, 因为它最先进入内存

LRU算法: 将淘汰第1页, 无需回写, 因为它最久没被访问了

NRU算法: 将淘汰第1页, 无需回写, 因为它最近没被访问过, 也没被修改过, 是最佳淘汰页

# 第6章 输入输出系统

在设备管理中，什么是设备独立性？如何实现设备独立性？

**解:**

设备独立性

   	1. 设备分配时的灵活性: 逻辑设备和物理设备间可以是多对多的映射关系, 提高了物理设备的共享性和灵活性. 例如: 某逻辑名可对应一类设备，提高容错性；几个逻辑名可对应某一个设备，提高共享性
   	2. 易于实现 I/O 重定向: 用于 I/O 操作的设备可以重定向，而不必改变应用程序，只需改变逻辑设备表的映射关系。例如：测试打印程序时可以将输出设备由打印机改为显示器, 以节省纸张

实现设备独立性

	1. 要定义逻辑设备, 物理设备

   	2. 需要逻辑设备表, 建立逻辑设备与物理设备的映射关系
   	3. 要在物理设备的驱动程序之上设置设备独立性软件

---

为什么要引入 SPOOLING 技术？SPOOLING 技术可带来哪些好处？

**解:**

1. 用常驻内存的进程去模拟外围机, 把一台物理 I/O 设备虚拟为多台逻辑 I/O 设备
2. 把独占设备改造为逻辑共享设备: 分配设备的实质是分配输入/输出井，并为进程分配一个存储区和建立一张 I/O 请求表。
3. 使进程对独占设备的使用与物理设备分离, 使进程与I/O设备之间的同步I/O方式转变为异步I/O方式, 提高了进程的并发度和效率
4. 提高了 I/O 速度: 把对低速设备操作变为对输入/输出井的操作。
5. 用空间换了时间

---

设某磁盘有 200 个柱面，编号为 0，1，2，···，199，磁头刚从 140 道移到 143 道完成了读写。若某时刻有 9 个磁盘请求分别对如下各道进行读写：86，147，91，177，94，150，102，175，130试分别求 FCFS、SSTF 及 SCAN（电梯）磁盘调度算法响应请求的次序及磁头移动的总距离。

**解:**

FCFS

- 次序: 143 -> 86 -> 147 -> 91 -> 177 -> 94 -> 150 -> 102 -> 175 -> 130
- 磁头移动的总距离: 57 + 61 + 56 + 86 + 83 + 56 + 48 + 73 + 45 = **<u>565</u>**

SSTF

- 次序: 143 -> 147 -> 150 -> 130 -> 102 -> 94 -> 91 -> 86 -> 175 -> 177
- 磁头移动的总距离: 4 + 3 + 20 + 28 + 8 + 3 + 5 + 89 + 2 = <u>**162**</u>

SCAN电梯

- 次序: 143 -> 147 -> 150 -> 175 -> 177 -> 130 -> 102 -> 94 -> 91 -> 86
- 磁头移动的总距离: 4 + 3 + 25 + 2 + 47 + 28 + 8 + 3 + 5 = **<u>125</u>**

---

设磁鼓上分为 20 个区，每区存放一个记录，磁鼓旋转一周需 20 毫秒，读出每个记录平均需用 1 毫秒，读出后经 2 毫秒处理，再继续处理下一个记录。在不知当前磁鼓位置的情况下：
（1）顺序存放记录 1、···、记录 20 时，试计算读出并处理 20 个记录的总时间；
（2）给出优化分布 20 个记录的一种方案，使得所花的总处理时间减少，且计算出这个方案所花的总时间。

**解:**

(1)定位记录1平均需要20 / 2 = 10ms, 读出记录1花1ms, 处理记录1花2ms, 因为使顺序存放, 所以此时磁头移动到了记录4, 磁头重新移动到记录2需要再转过20 - (4 - 2) = 18个区, 花18ms, 读出记录2花1ms, 处理记录2花2ms, 剩下的记录3~20都如记录2, 所以总时间: 10 + 1 + 2 + (18 + 1 + 2) * 19 =  **<u>412ms</u>**

(2)优化分布方案: 1, 8, 15, 2, 9, 16, 3, 10, 17, 4, 11, 18, 5, 12, 19, 6, 13, 20, 7, 14

定位记录1平均需要20 / 2 = 10ms, 读出记录1花1ms, 处理记录1花2ms, 此时磁头移动到了记录2, 读出记录2花1ms, 处理记录2花2ms, 剩下的记录也如此, 所以总时间: 10 + (1 + 2) * 20 =  <u>**70ms**</u>