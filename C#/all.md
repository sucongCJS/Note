# 概念

## .NET框架组件

- CLR (Common Language Runtime)  公共语言运行库
- 类库
  - 类库中的每个类均按照功能划分到不同的命名空间下面

## 命名空间

> 对类的一种逻辑上的分组，即将类按照某种关系或联系划分到不同的命名空间下。

- 命名空间又可以包含其它的命名空间
  - 语法: `命名空间.命名空间.....命名空间.类名称.静态方法(参数, ......);`

## 关键字

### using

- 引用指令

  - 用于为命名空间导入其他命名空间中定义的类型

- 别名指令

  - 用于简化命名空间的表达形式

  - ```c#
    using wf = System.Windows.Form;
    System.Windows.Form.MessageBox.Show("hello"); = wf.MessageBox.Show("hello");
    ```

- 语句

  - 定义一个范围, 执行到范围末尾, 会立即释放using的小括号内创建的对象
  - 文件流, 数据库连接

# 数据类型

## 值类型

> 值类型变量直接在堆栈中保存变量的**值**

- 种类
  - 简单类型
  - 枚举
    - enum E{…}
  - 自定义类型
    - struct S{…}
  - 可空类型

## 引用类型

> 引用类型的变量在堆栈中保存变量的**引用地址**

- 种类
  - 类
  - 接口
  - 数组
  - 委托

## 区别

| 特征             | 值类型             | 引用类型                     |
| ---------------- | ------------------ | ---------------------------- |
| 变量中保存的内容 | 实际数据           | 指向实际数据的引用指针       |
| 内存空间配置     | 堆栈(**stack**)    | 受管制的堆(managed **heap**) |
| 执行效率         | 较快               | 较慢                         |
| 内存需求         | 较少               | 较多?                        |
| 内存释放时间点   | 超过变量的作用域时 | 有垃圾回收基址负责回收       |

## Object

- 所有类型的基类
- 可以显式转换为任何一种对象

## 数据转换

### 隐式转换

> 低精度, 小范围的数据转换为高精度, 大范围的数据类型

### 显示转换

### 装箱

> boxing

- 将值类型隐式转换为Object类型

- 装箱一个数值会为其分配一个对象实例, 并将该数值复制到新对象中

  ```c#
  int i = 123;
  object o = i; // o引用了堆上int类型的数值, 而该数值是赋给变量i的数值的备份
  ```

### 拆箱

> unboxing

- 显式地把Object类型转换为值类型

- 步骤

  1. 检查对象实例, 确认它是否包含了值类型的数
  2. 把实例中的值复制到值类型的

  ```c#
  int i = 123; // 值类型
  object box = i; // 装箱
  int j = (int)box; // 拆箱
  ```

  

# 类

## 关键字

### internal

- 同一程序集中的代码都可以访问, 程序集外的其他代码无法访问

### protexted

- 类的内部可访问, 或者从该类继承的子类可以访问

### static

- 静态类
  - 仅包含静态成员
  - 无法实例化 (这与在非静态类中定义私有构造函数可阻止类被实例化的机制相似)
  - 不能包含实例构造函数, 但可以包含静态构造函数
  - 是密封的, 因此不能被继承
- 静态方法
  - 可以被重载, 但不能被重写, 因为静态方法属于类, 而不是输入类的实例
- 静态字段

### readonly

- 在程序运行期间只能初始化一次的字段, 初始化后字段的值不能再更改
- `static readonly` 作用和用`const`声明定义一个常量相似

## 构造函数

- 可以被重载, 不能被继承
- 种类
  - 实例构造函数
  - 默认构造函数
    - 数值型初始化为0
    - bool型初始化为false
    - 引用型初始化为null

## 析构函数

- 不带参数, 不包含访问修饰符
- 自动调用

## 初始化顺序

1. 继承类静态变量
2. 继承类实例变量
3. 基类静态变量
4. 基类实例变量
5. 基类构造方法
6. 继承类构造方法 

## 字段

- 类的成员, "类"级别变量
- 一般将私有或受保护的变量声明为字段, 向类外部代码公开的数据应通过方法, 属性, 索引器提供

## 局部变量

- 块的成员, "块"级别的变量
- 局部变量不会被自动初始化

## 继承

- C#只能单继承
- 继承多个可用接口
- 所有的类从 `System.Object`派生, `Object`本身有一些方法
  - 如`Equals()`判断地址是否先相同
- 构造函数不能被继承
- C#中类对象构造的顺序
  1. 按照类中成员的声明顺序进行构造
     2. 从扩充类(派生类)一次向上寻找其基类, 直到找到最初的基类 (所以首先会调用System.Object的构造函数)
     3. 默认执行的是基类不带参数的构造函数

## 多态

- 通过继承实现多态
  - 
- 通过抽象类实现多态
  - 抽象类的部分或全部成员不一定都要实现, 但是要在继承类中全部实现
  - 抽象类中已实现的成员仍可被重写
- 通过接口实现多态

## 重写

- 虚拟方法
  - 虚拟方法不能声明为静态(static)的 (静态方法是在类层面的, 虚拟方法是在对象层面的)
  - virtual 和 private 不能共用
  - 重写方法的名称, 参数个数, 参数类型, 返回类型要和虚拟方法一样
  - 扩充类没写override的话, 调用的是基类的同名方法

## 隐藏

- 隐藏基类

# 结构

- 值类型, 保存在堆栈中
- 默认隐式从Object类继承
- 不能继承其他结构, 但可用接口

# WPF

## 事件路由决策

- 直接

  - 该事件值针对元素自身, 不会再路由到其他元素

- 冒泡

  - 从事件源依次向父元素方向"向上"查找, 直到找到根元素

  - 目的是搜索父元素中是否包含针对该元素的附加事件声明

  - 这样就可以在某个父元素上一次性为多个子元素注册同一个事件

  - 从Button开始, 首先会执行StackPanel注册的事件, 然后是Border注册的事件, Window注册的事件

    ```xaml
    <Window>
        <Border>
            <StackPanel Button.Click = "Btn_Click">
                <Button Name="yes">
                <Button Name="no">
            </StackPanel>
        </Border>
    </Window>
    ```

- 隧道

  - 跟冒泡路由相反: 从根元素开始向子元素依次路由, 直到找到事件源为止

# C#独特

- bool 只认True, False, int i=5; if(i)… (❌)

