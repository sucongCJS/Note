# 概论

- 完整的计算机系统包括硬件系统与软件系统
  - 硬件: 中央处理机、存储器和外部设备等
  - 软件: 计算机的运行程序和相应的文档
- 软件与硬件的等价性原理
  - 任何一个由软件所完成的操作也可以直接由硬件来实现，任何一条由硬件所执行的指令也能用软件来完成
  - 等价是指软硬件在逻辑功能上的等价，并不是性能和成本的等价

## 冯诺依曼结构

![image-20200217115453516](%E8%AE%A1%E7%BB%84.assets/image-20200217115453516.png)

### 层次结构

![image-20200225112441278](%E8%AE%A1%E7%BB%84.assets/image-20200225112441278.png)

- 不同用户处在不同层次
- 不同层次具有不同属性
- 不同层次使用不同工具
- 越高层代码效率越低



- 指令集架构

  > instruction set architecture

  - A realization of an ISA is called an implementation. An ISA permits multiple implementations that may vary in performance, physical size, and monetary cost (among other things)
  - ISA serves as the **interface between software and hardware**. 
  - Software that has been written for an ISA can run on different implementations of the same ISA.

### 主机

- 运算器

  - 算数运算, 逻辑计算

  - 基本结构: ALU(Arithmetic Logical Unit), 寄存器, 连接通路 

    ![image-20200217120655600](%E8%AE%A1%E7%BB%84.assets/image-20200217120655600.png)

- 控制器

  - 产生指令执行过程所需要的所有控制信号, 控制相关功能部件执行相应操作

  - 控制信号形式: 电平信号, 脉冲信号

    ![image-20200217120607273](%E8%AE%A1%E7%BB%84.assets/image-20200217120607273.png)

  - 产生控制信号的依据: 指令, 状态, 时序 

    ![image-20200217120735810](%E8%AE%A1%E7%BB%84.assets/image-20200217120735810.png)

  - 控制信号的产生方式: 微程序, 硬布线

- 存储器

  - 功能: 存储原程序, 原数据, 运算中间结果
  - 工作模式: 读/写

### 外设

- 输入设备
- 输出设备
- 外存储器

### 总线

- 地址线
- 控制线
- 数据线

## 性能评价

### 非时间指标

- 机器字长: 机器一次能处理的二进制位数
  - 一般与运算器的数据位, 通用寄存器的位数相同
- 总线宽度: 数据总线一次能并行传送的最大信息的位数
- 主存容量
- 存储带宽

### 时间指标

- 主频 $f$: CPU工作的时钟频率, 即CPU内数字脉冲信号振荡的频率

  - 主频 = 外频 * 倍频
  - 与CPU的运算能力没有直接关系

- 时钟周期 $T$

- 外频

  - <u>CPU与主板之间同步运行的速度</u>
  - 在早期的绝大部分电脑系统中外频，也是<u>内存与主板之间的同步运行的速度</u>，在这种方式下，可以理解为CPU的外频直接与内存相连通，实现两者间的同步运行状态

- 倍频

  - CPU主频与外频之间的倍数
  - 倍频技术能够使 CPU内部工作频率变为外部频率的倍数，从而通过提升倍频而达到提升主频的目的
  - 倍频技术就是使外部设备可以工作在一个较低外频上

- CPI (Clock cycles Per Instruction)

  - 执行一条指令(平均)需要的时钟周期数 (T的个数)

- IPC (Instruction Per Clock)

  - 每T执行的指令条数
  - CPU性能 = IPC * 频率(MHz)

- MIPS (Million Instruction Per Second)

  - $MIPS = \frac{f}{CPI * 10^6}$(全性能公式) , $\frac{f}{CPI}$表示一秒执行的指令数
  - <img src="%E8%AE%A1%E7%BB%84.assets/image-20200217140102604.png" alt="image-20200217140102604" style="zoom:67%;" />
  - CPU 时间
    - 执行一段程序所需的时间
    - CPU时间 = $总指令数 * CPI * T$
    - CPU时间 = $\frac{总指令数}{MIPS * 10^6}$

  <img src="%E8%AE%A1%E7%BB%84.assets/image-20200217144323663.png" alt="image-20200217144323663"  />


## 固件

> firmware

- 固件位于软件和硬件之间
- 像软件一样，他是一个被电脑所运行的程序
- 通常它是位于[特殊应用集成电路](https://zh.wikipedia.org/wiki/特殊應用積體電路)（ASIC）或[可编程逻辑器件](https://zh.wikipedia.org/wiki/可程式邏輯裝置)（PLD）之中的[闪存](https://zh.wikipedia.org/wiki/快閃記憶體)或[EEPROM](https://zh.wikipedia.org/wiki/EEPROM)或[PROM](https://zh.wikipedia.org/wiki/PROM)里
- 功能类似软件，形态类似硬件

# 数据表示

## 机器数

### 原码

### 反码

### 补码

![image-20200525144610275](%E8%AE%A1%E7%BB%84.assets/image-20200525144610275.png)

### 移码

> Offset Binary 增码

- 移码表示浮点数的阶码, IEEE754中阶码用移码表示

- 数值位与数的补码相同, 符号位与补码相反

- 1表示正数的符号, 0表示负数的符号

- 移码在逻辑比较操作中可以得到和真值比较相同的结果, 补码则当且仅当符号相同时逻辑比较操作的结果和真值比较相同，否则比较结果将颠倒（负值比正值大）

  ![image-20200303085029658](%E8%AE%A1%E7%BB%84.assets/image-20200303085029658.png)

## 小数

### 定点

- 可表示定点小数和整数
- 定点小数
  - 表现形式: $X_0.X_1X_2X_3X_4...X_n$
  - 表示数的范围(补码为例): $-1<=x<=1-2^n$  1.0000000~0.1111111
- 定点整数
  - 表现形式: $X_0X_1X_2X_3X_4...X_n.$
  - 表示数的范围(补码为例): $-2^n<=x<=2^n-1$  10000000.~01111111.

### 浮点数

![image-20200303153147662](%E8%AE%A1%E7%BB%84.assets/image-20200303153147662.png)

- 符号位 s（Sign）决定数是正数（s＝0）还是负数（s＝1），而对于数值 0 的符号位解释则作为特殊情况处理。

![image-20200303091346662](%E8%AE%A1%E7%BB%84.assets/image-20200303091346662.png)

![image-20200303091835298](%E8%AE%A1%E7%BB%84.assets/image-20200303091835298.png)

![image-20200303092245764](%E8%AE%A1%E7%BB%84.assets/image-20200303092245764.png)

- 指数是移码, 采用偏移值
- 单精度偏移值为127, 双精度偏移值1023
- 将浮点数的阶码值变成非负整数, 便于浮点数的比较和排序
- 尾数形式为1.XXXXXX, 其中M部分保存的是XXXXXX(由于第一位总是等于 1，因此就不显式地表示它, 以获得一个额外精度位)
- 浮点数溢出分为上溢和下溢两种。
  - 当运算结果大于机器所能表示的最大正数，或小于机器所能表示的最小负数时称为上溢，数据出现上溢时计算机要停止运算操作，作溢出处理
  - 当运算结果介于0和机器所能表示的最小正数之间，或介于机器所能表示的最大负数和0之间时称为下溢，数据出现下溢时，计算机不做任何处理，将运算结果置为机器零即可

#### 单精度

- 还原真值 $N=(-1)^S * 2^{E-127}*1.M$  

  - $(-1)^S$表示符号位

  - $E-127$是因为移码表示加了127偏移值, 还原真值要减掉

    ![image-20200303111824454](%E8%AE%A1%E7%BB%84.assets/image-20200303111824454.png)

    ![image-20200303114008467](%E8%AE%A1%E7%BB%84.assets/image-20200303114008467.png)

- [特殊值](http://c.biancheng.net/view/314.html)

## 数据校验

[link](https://www.cnblogs.com/china520/p/10392408.html)

![image-20200303165039412](%E8%AE%A1%E7%BB%84.assets/image-20200303165039412.png)

- 码距是4, 错了1, 2, 3个数都可以检测出来, 错了4个就检测不出来了
- 码距是2, 如果只错了1位, 可以检测出来, 如果错了2或以上位, 检测不出来, 因为错的那个编码和编码系统中的其他码的最小距离大于等于2, 无法判断

### 奇偶校验

- 无论数据位多少位, 校验位只有一位
- 1的个数为1是奇校验, 否则偶校验
- 只能检测奇数位错误
- 无错结论不可靠, 是一种错误检测编码
- 不能定位错误, 不具备纠错能力

### CRC校验

> 循环冗余码

- N = k+r <= 2$^r$ -1
  - k 有效位
  - r 校验位
- 为什么大批量数据不用奇偶校验: 在每个字符后增加一位校验位会增加大量的额外开销；尤其在网络通信中，对传输的二进制比特流没有必要再分解成一个个字符，因而无法采用奇偶校验码
- 关于多项式G(x)
  - 长度为 r+1 位
  - 使用多项式是为了在进行二进制计算时无需考虑进位问题
  - 最高位最低为必须为1
  - 当被传送信息(CRC码)任何一位发生错误时, 被生成多项式做除后应该使余数不为0
  - 对不为0余数继续进行模2除运算, 余数会循环

#### 模2除运算

![image-20200313195746683](%E8%AE%A1%E7%BB%84.assets/image-20200313195746683.png)



#### 编码方法

1. 根据待校验信息的长度, 确定校验位的位数r
2. 选择位数为r+1的生成多项式
3. 合并待校验的信息和校验码, 得到`Q(X)'`
4. 对`Q(X)'`按模2运算, 得到r位校验信息
5. 用得到的余数替换`Q(X)'`的后r位得到CRC编码

### 海明编码

- 设k+r位海明码, r位校验位分别位于k海明编码的第2$^{i-1}(i=1, 2, ... r)$位上, 其余位使被校验位的数据位

# 运算

## 溢出

溢出的检测方法

- 有符号数
  - 对操作数和运算结果的符号位进行检测, 当**结果的符号位与操作数的符号位不相同**的时候就表面发生了溢出

     ![image-20200525123210045](%E8%AE%A1%E7%BB%84.assets/image-20200525123210045.png)

  - 对最高数据位和符号进位进行检测

    <img src="%E8%AE%A1%E7%BB%84.assets/image-20200525121733150.png" alt="image-20200525121733150" style="zoom:67%;" />

  - 用变型补码

    <img src="%E8%AE%A1%E7%BB%84.assets/image-20200525121816680.png" alt="image-20200525121816680" style="zoom:67%;" />

- 无符号数

  - 加法的溢出可以用ALU的进位表示

  - 减法的溢出可以用带加/减功能的ALU的进位取反后表示

  - ![image-20200525123528646](%E8%AE%A1%E7%BB%84.assets/image-20200525123528646.png)

    <img src="%E8%AE%A1%E7%BB%84.assets/image-20200525123658793.png" alt="image-20200525123658793" style="zoom:80%;" />

    二路选择器, 异或 [link](https://www.bilibili.com/video/BV1Ct411V7dj?p=17)

## 原码一位乘法

- 乘法可由加法实现
- 存在的问题
  - 需要多输入的全加器
  - 需要长度为2n的积寄存器
  - 对应乘数的不同位, 部分积左移次数不同, 且乘法过程中总移位次数多

![image-20200313205224195](%E8%AE%A1%E7%BB%84.assets/image-20200313205224195.png)

- 例子

![image-20200313205407287](%E8%AE%A1%E7%BB%84.assets/image-20200313205407287.png)



## 补码一位乘法

推导

- <img src="%E8%AE%A1%E7%BB%84.assets/image-20200525145104108.png" alt="image-20200525145104108" style="zoom:80%;" />
- ![image-20200525162356019](%E8%AE%A1%E7%BB%84.assets/image-20200525162356019.png)

运算规则

- <img src="%E8%AE%A1%E7%BB%84.assets/image-20200525165405945.png" alt="image-20200525165405945" style="zoom:67%;" />

- 如果$y_{n+1}=y_n$部分积加0, 部分积算术右移1位
- 如果$y_{n+1}y_n=10$部分积加$[x]_补$, 部分积算术右移1位
- 如果$y_{n+1}y_n=01$部分积加$[-x]_补$, 部分积算术右移1位
- 重复进行n+1步, 但最后一步不移位

![image-20200313205910007](%E8%AE%A1%E7%BB%84.assets/image-20200313205910007.png)

![image-20200313205915966](%E8%AE%A1%E7%BB%84.assets/image-20200313205915966.png)

### Booth算法

![image-20200526011810642](%E8%AE%A1%E7%BB%84.assets/image-20200526011810642.png)

![image-20200526011951807](%E8%AE%A1%E7%BB%84.assets/image-20200526011951807.png)

## 定点数除法

![image-20200313210709878](%E8%AE%A1%E7%BB%84.assets/image-20200313210709878.png)

- 余数位正数时

  - 够减, 商上1, 将余数左移一位, 再与除数做减法比较
  - 不够减, 商上0, 加除数恢复成原来的值, 将余数左移一位, 再与除数做减法比较

- 例子

  ![image-20200313210951401](%E8%AE%A1%E7%BB%84.assets/image-20200313210951401.png)

  ![image-20200313211006997](%E8%AE%A1%E7%BB%84.assets/image-20200313211006997.png)

## 原码除法

### 恢复余数法

![image-20200526012916656](%E8%AE%A1%E7%BB%84.assets/image-20200526012916656.png)

![image-20200526012936713](%E8%AE%A1%E7%BB%84.assets/image-20200526012936713.png)

![image-20200526013025786](%E8%AE%A1%E7%BB%84.assets/image-20200526013025786.png)

### 不恢复余数法

![image-20200526013257062](%E8%AE%A1%E7%BB%84.assets/image-20200526013257062.png)

![image-20200526013335460](%E8%AE%A1%E7%BB%84.assets/image-20200526013335460.png)

![image-20200526013353993](%E8%AE%A1%E7%BB%84.assets/image-20200526013353993.png)



## 浮点数加减运算

- 步骤

  - 设$x=2^{Ex}·Mx, y=2^{Ey}·My$, 则: $x+y=(2^{Ex-Ey}·Mx+My)*2^{Ey} (Ey\geq Ex)$

  1. 对阶
     1. 求阶差
     2. 右移阶码小的浮点数的尾数并同步增加其阶码, 直到两数阶码相等
  2. 尾数加/减运算
  3. 结果规格化
  4. 舍入
     - 0舍1入: 若右移出的是1则在最低位加1
     - 恒置1: 只要数字1被移掉, 就将最后一位恒置成1
  5. 溢出处理
     - 阶码上溢: 阶码的符号位为01
     - 阶码下溢: 价码的符号位为10

- 例子

  ![image-20200313211817262](%E8%AE%A1%E7%BB%84.assets/image-20200313211817262.png)

# 指令系统

## 寻址

![image-20200403183953734](%E8%AE%A1%E7%BB%84.assets/image-20200403183953734.png)

## MIPS

MIPS32

### 指令

<img src="%E8%AE%A1%E7%BB%84.assets/image-20200403194841575.png" alt="image-20200403194841575" style="zoom:80%;" />

- 没有寻址方式字段

#### R

![image-20200406180116284](%E8%AE%A1%E7%BB%84.assets/image-20200406180116284.png)

![image-20200406180148270](%E8%AE%A1%E7%BB%84.assets/image-20200406180148270.png)

![image-20200406180156410](%E8%AE%A1%E7%BB%84.assets/image-20200406180156410.png)

![image-20200406180205256](%E8%AE%A1%E7%BB%84.assets/image-20200406180205256.png)

#### I

![image-20200406180221139](%E8%AE%A1%E7%BB%84.assets/image-20200406180221139.png)

![image-20200406180242170](%E8%AE%A1%E7%BB%84.assets/image-20200406180242170.png)

![image-20200406180324834](%E8%AE%A1%E7%BB%84.assets/image-20200406180324834.png)

![image-20200406180410030](%E8%AE%A1%E7%BB%84.assets/image-20200406180410030.png)

![image-20200406180423150](%E8%AE%A1%E7%BB%84.assets/image-20200406180423150.png)

#### J

![image-20200406180442661](%E8%AE%A1%E7%BB%84.assets/image-20200406180442661.png)

- J型指令只使用伪直接寻址方式

### 寄存器

![image-20200406173703861](%E8%AE%A1%E7%BB%84.assets/image-20200406173703861.png)

### 寻址方式

![image-20200406173918795](%E8%AE%A1%E7%BB%84.assets/image-20200406173918795.png)

#### 立即数寻址

![image-20200406174059623](%E8%AE%A1%E7%BB%84.assets/image-20200406174059623.png)

#### 寄存器直接寻址

![image-20200406174110485](%E8%AE%A1%E7%BB%84.assets/image-20200406174110485.png)

#### 基址寻址

![image-20200406174126443](%E8%AE%A1%E7%BB%84.assets/image-20200406174126443.png)

#### 相对寻址

![image-20200406174231799](%E8%AE%A1%E7%BB%84.assets/image-20200406174231799.png)

- 因为MIPS的指令长度为4个字节，所以指令地址一定为4的倍数，因而地址后两位一定为0，因此offset左移两位使偏移量变为4的倍数，保持地址最后两位为0

#### 伪直接寻址

> 页面寻址

![image-20200406174258376](%E8%AE%A1%E7%BB%84.assets/image-20200406174258376.png)

 





# 复习

- https://zhuanlan.zhihu.com/p/38534417

## 概论

下列说法中，错误的是（ B ）
A.**固件功能类似软件，形态类似硬件**
B.寄存器的数据位对微程序级用户透明
C.软件与硬件具有逻辑功能的等效性
D.计算机系统层次结构中，微程序属于硬件级

所谓固件(Firmware)就是写入EROM或EPROM(可编程只读存来储器)中的程序，通俗的理解就是“固化的软件”。更简单的说，Firmware就是BIOS的软件，但又与普通软件完全不同，它是固化在集成电路自内部的程序代码，负责控制和协调集成电路的功能



计算机系统层次结构

![这里写图片描述](%E8%AE%A1%E7%BB%84.assets/19193711_Xn1n.jpg)

![这里写图片描述](%E8%AE%A1%E7%BB%84.assets/19193712_GVwG.jpg)

---

3、CPU地址线数量与下列哪项指标密切相关（ B ）
A.运算精确度
B.内存容量
C.存储数据位
D.运算速度

---

4、下列属于冯•诺依曼计算机的核心思想是（ C ）
A.采用补码
B.采用总线
C.存储程序和程序控制
D.存储器按地址访问

![image-20200512003900131](%E8%AE%A1%E7%BB%84.assets/image-20200512003900131.png)

---

下列关于计算机系统层次结构的描述中，正确的是  ABCD

A.低层代码执行效率比高层代码执行效率高

B.低层用户对硬件的透明性比高层用户要低

C.**指令集架构层是软、硬件间的接口**

D.不同层次面向不同用户，看到计算机的属性不同

- 处理器架构就是处理器的硬件架构，称为微架构, 是一堆硬件电路，去实现指令集所规定的操作运算
- **指令集决定了处理器的架构**，因为处理器架构就是用硬件电路实现指令集。但是具体用什么样的处理器架构，设计怎样的硬件电路，每个人设计的都可以不一样。
- MIPS是一种采取[精简指令集](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%B2%BE%E7%B0%A1%E6%8C%87%E4%BB%A4%E9%9B%86)（RISC）的[处理器](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%99%95%E7%90%86%E5%99%A8)架构，既有指令集，也有相应的处理器架构。
- 要设计处理器，首先就需要有**指令集规定处理器相应操作**，**通过指令集去控制处理器实现相应功能**。但处理器是一堆硬件电路，只能识别二进制数据，所以指令集是由一堆二进制数据组成。

---

下列计算机系统性能评价的描述中正确的是 AB
A.主频高的机器性能不一定高
B.同一程序在不同机器上运行时得到的MIPS值不一定相同
C.程序MIPS值越高，计算机的性能越高
D.程序的CPI值越低，计算机的性能越高  没有保证程序一样?

- CPU性能 = IPC(Instruction Per Clock) * 频率(MHz)
- 主频 = 外频 * 倍频

---

下列关于计算机字长的描述中正确的是 AB

**字长一般与运算器的数据位相同**

**字长一般与通用寄存器的位数相同**

字长一般与存储器的地址位相同

字长一般与存储器数据位相同

## 数据表示

设G(x) = 1011，某(7,4)码为K1K2K3K4K5K6K7，仅K7出错时进行CRC校验得到的余数为001，当仅K5出错时，进行CRC校验得到的余数为 100

```
         00
     /------
1011/ 0010
      0000
      ------
       0100......K6 = 010, 注意顺序
       0000
      ------
        100......K5 = 100
```

---

2^100 mod 7 =(((2^5 ))^5)) ^4 mod 7 = ((2^5 mod 7)^5 mod 7) ^ 4 mod 7 = 2

---

某十六进制浮点数A3D00000中最高8位是阶码（含1位阶符），尾数是最低24位（含1位数符），若阶码和尾数均采用补码，则该浮点数的十进制真值是  -0.375×2^(-93)

```
A3 = 1010 0011(补码) = -93
D00000 = 1101 0000 0000 0000 0000 0000(补码) -> 0011 0000 0000 0000 0000 0000(原码), 0011, 第一位是符号, 011 是小数部分, 0.011
```

![image-20200512123027818](%E8%AE%A1%E7%BB%84.assets/image-20200512123027818.png)

![image-20200512123052751](%E8%AE%A1%E7%BB%84.assets/image-20200512123052751.png)

![image-20200512123414460](%E8%AE%A1%E7%BB%84.assets/image-20200512123414460.png)

13/128 = 13*2^-7

---

字长8位的某二进制补码整数为11011010，则该数的标准移码是  01011010

移码就是将补码的符号位取反

移码，可以理解为补码加上偏移值，即将整个取值范围右移一段距离，从移码中可以直接看出真值的大小。

---

下列对海明校验的描述中，正确的描述是  C

A.分成r组时，可以得到r位指误码，因此可以区分2^r种只有1位出错的情况

B.在任何条件下，海明校验都无法检测到多位数据同时出错的情况

C.待编码数据长度为4位，再增加3位校验码就可以检测到仅1位数据出错的情况并纠错

D.海明校验码的码距与校验位的位数没有关系

在一个码组内为了检测e个误码，要求最小码距d应该满足： d>=e+1

在一个码组内为了纠正t个误码，要求最小码距d应该满足： d>=2t+1

同时检错纠错: d>=e+t+1

---

设规格化浮点数的阶码为k+1位(包含1位符号位)、尾数为n +1位(包含一位符号位)，若阶码和尾数均采用**补码**数据表示，下列关于该浮点数表示范围的描述中

最小正数: 1/2 * 2\^(-2^k)		->		1/2 * 2^-100000000(k个0, 总共k+1位)

最大正数: (1-2^(-n)) * 2^ (2^k - 1)		->	0.111111111*2^11111111111

最小负数: -2^(2 ^k - 1)		->		-1.0000000000*2^11111111111

最大负数: -(1/2 + 2^-n) \* 2 ^(-2 ^k)		->		-0.10000000001*2^-1000000000



- **原码表示的尾数判断浮点数是否规格化：第一个数值位是否为“1”,是,规格化；否,非规格化**
- **补码表示的尾数判断浮点数是否规格化：符号位与第一个数值位是否相异,是,规格化；否,非规格化（-1/2除外）**

![image-20200513214508176](%E8%AE%A1%E7%BB%84.assets/image-20200513214508176.png)

上图没用补码

![image-20200514003638634](%E8%AE%A1%E7%BB%84.assets/image-20200514003638634.png)

![image-20200514003701365](%E8%AE%A1%E7%BB%84.assets/image-20200514003701365.png)

---

正数的源码，**反码**，补码是一样的

---

十进制数5对应的32位IEEE754 格式的机器数为 （40A00000）H (采用十六进制表示,填写答案时不需要写最后的H) 

<img src="%E9%A2%98.assets/image-20200512120942780.png" alt="image-20200512120942780" style="zoom: 67%;" /> 

S控制符号

<img src="%E9%A2%98.assets/image-20200512121119724.png" alt="image-20200512121119724" style="zoom:67%;" />

---

某IEEE754格式32位浮点数，若其对应的十六进制代码为ABE00000，则浮点数的真值为  -1.75×2^(-40)

**浮点数和定点数的移码偏置值不同，定点数是2^n， 浮点数是2^n-1** [link](https://blog.csdn.net/sinat_35418761/article/details/53009420)

```
1010 1011 1110 0000 0000 0000 0000 0000
1 01010111 11000000000000000000000
S = 1, M = 11, 所以是-1.75
E = 01010111 (移码)
e = E - 127 = 1101 1000 (移码转补码)
e就是-40
```

---

当 -1 < x < 0时， [x]补=2+x

![image-20200515114810935](%E8%AE%A1%E7%BB%84.assets/image-20200515114810935.png)

---

字长5位的待编码二进制有效数据为11011，对它进行CRC编码时采用的生成多项式代码为1011，则得到的CRC编码为 001

11011001**000** 和 1011 做模二除

---

存储器中地址号分别为1000#、1001#、1002#、1003的4个连续存储单元，分别保存的字节数据是1A、2B、3C、4D，如果数据字长为32位,存储器采用的是小端对齐模式，则这4个存储单元存储的数据值应被解析为 4D3C2B1A

```
大端: 高高低低数字0x12 34 56 78在内存中的表示形式为：

1)大端模式：

低地址 ------------------> 高地址
0x12  |  0x34  |  0x56  |  0x78

2)小端模式：

低地址 ------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12
```

---

设机器字长为16位，定点表示时，数据位15位，符号位1位，则定点原码表示时能表示的最小负数为   -32767

![image-20200517114038410](%E8%AE%A1%E7%BB%84.assets/image-20200517114038410.png)

## 运算方法与运算器

单符号位补码表示的两个同号数相加或异号数相减时，所得结果的符号位SF和进位标志CF进行（ ）运算为1时，表示运算的结果产生溢出  异或

![image-20200517132600416](%E8%AE%A1%E7%BB%84.assets/image-20200517132600416.png)

<img src="%E9%A2%98.assets/image-20200517132526185.png" alt="image-20200517132526185" style="zoom:67%;" />

<img src="%E9%A2%98.assets/image-20200517132541050.png" alt="image-20200517132541050" style="zoom:80%;" />

---

下列是组成运算器的部件的是

状态寄存器

ALU

数据总线

### 浮点数

加减运算过程一般包括对阶、尾数运算、规格化、舍入和判溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为  5  位和  7  位  (  均含**2位符号位**  )  。若有两个数  X=27    ×  29/32  ，  Y=25    ×  5/8  ，则浮点加法计算  X+Y  的最终结果是： 溢出

- 00111 1100010
- 00111  0100010
- 01000 0010001
- 发生溢出



小数化二进制：29/32=0.1110100，5/8=0.1010000

求阶差：△E=7-5=[7]补+[-5]补=00010=2 

对阶：2^5 x 0.1010000 = 2^7 x 0.0010100 

2^7 x 0.1110100 + 2^7 x 0.0010100 = 2^00111 x 1.0001000 

执行尾数右移规格化为2^01110 x 0.100010 

因为01110的高2位符号位不同，**阶码溢出，说明结果溢出**

---

以下说法正确的是 ABCD

A. 浮点运算可由阶码运算和尾数运算两个部分联合实现

B. 在定点小数补码一位除法中，为了避免溢出，被除数的绝对值一定要小于除数的绝对值???

C. 补码加减交替法是一种不恢复余数法

D. n位小数的补码一位乘法（Booth算法），需做n+1次运算，第n+1次不移位

### 双符号位

若采用双符号位补码运算，运算结果的符号为 10，则（）



产生了下溢  运算结果溢出，结果为正数

---

采用补码数据表示的ALU中采用双符号位判断溢出时，直接使用被加数和加数补码的符号位进行判断  ×

## 存储系统

某计算机字长是32位，它的存储容量是256KB，按字编址，它的寻址范围是______。

- 64K

（256\*1024\*8位）/32位=64K

---

计算机字长32位，主存容量为128MB，按**字**编址，其寻址范围为  0 ~ 32M-1

$128*1024*1024*8/32/1024/1024$

---

某计算机存储器按字节编址，采用小端方式存放数据。 

  假定编译器规定int型和short型长度分别为32位和16位 

  并且数据按边界对齐存储。 

  某C语言程序段如下： 

```c
struct 
{
    int a;
    char b;
    short c;
} record;
record.a = 273;
record.b = 'A';
record.c = 273;
```

  若record变量的首地址为0XC008， 

  则低地址0XC008中内容及record.c的地址是 （ ）  0X11、0XC00E

```
273 = 0x111
0xC008 11
0xC009 01
0xC00A 00
0xC00B 00 .......a
0xC00D 65 .......b
0xC00E <null>....对齐
0xC00F 11
0xC010 01 .......c
```

---

字位结构为256Kｘ4位SRAM存储芯片，其地址引脚与数据引脚之和为 22

因为 为4位，所以数据线四根，

256K = 2^10 * 2^8 = 2^ 18;

---

某计算机字长 32位，下列地址属性中属于按双字长边界对齐的是  **存储器地址线低三位全部为0**



首先字长是32位, 一个字是4字节, 双字是8字节

低三位是0, 都是8的整数倍, 就对齐了!

---

### 映射

某计算机的Cache共有16块，采用2路组相联映射方式（即每组2块）。每个主存块大小为32字节，按字节编制。主存129号单元所在主存块应装入到的Cache组号是
  A.0  B. 2  C. 4  D.6

**答案：C**
考点：Cache组相联映射方式

**主存按字节变址，第129号单元代表第129个字节。主存129单元，所在的块号为129/32=4(从0开始编号)；**
**由于Cache共有16块，采用2路组相联，因此共有8组，0，1，2，…，7。**
**主存的某一字块按模8映像到Cache某组的任一字块中，即主存的第0，8，16…字块可以映像到Cache第0组2个字块的任一字块中，而129号单元是位于第4块主存块中，因此将映射到Cache第4组2个字块的任一字块中。**

---

7.一个组相联高速缓存由64个字块组成，每个字块有256字，分为8组，主存有4096个字块。请问：

①主存地址有多少位？

主存地址的划分如何？即：标志字段、组字段和块内地址字段各有多少位？



参考答案：

① 主存容量为4096块x256字=2^20字，故主存地址为20位。

② Cache容量为64块x256字= 8组x 8字块/ 组x 256字/字块。

主存容量按每8个字块对于Cache的8组，共有4096/8=512=2^9个组群

即：2^20 字=2^9 组群x 2^3块/组群 x 2^8字/块

因此，主存地址划分：标志位为9位，组号为3位，字块内地址为8位。

所以，Cache的每个字块的标志位有9位。

---

假定主存按字节编址，cache共有64行，采用直接映射方式，主存块大小为32字节，所有编号都从0开始。问主存第3000号单元所在主存块映射到的cache行号是( **29** )。（本题中的数字都是十进制数，答案也填十进制数）请输入答案



3000 / 32 = 93…..3000个字节, 每32字节一块, 一共分为了93块

93 - 64 = 29.....直接映射, 93块需要分两次

## CPU

用以指定待执行指令所在主存地址的寄存器是 D?

A.存储器地址寄存器MAR

B.数据缓冲寄存器

C.指令寄存器IR

D.程序计数器PC

控制和状态寄存器

- MAR: 存储器地址寄存器, 用于存放将访问的存储单元的地址
- MDR: 存储器数据寄存器, 用于存放欲存入存储器中的数据或最近从存储器中读出的数据
- PC: 程序计数器, 存放现行指令的地址
- IR: 指令寄存器, 存放当前欲执行的指令

---

某计算机采用微程序控制器的微指令格式采用编码方式组织，某互斥命令组由4个微命令组成，则微指令寄存器中相应字段的位数至少需(    )。 3

## I/O

8086 CPU对I/O接口的编址采用了（    ）。I/O端口独立编址, 不占用主存空间, 不影响主存容量, 但需要专用的I/O指令

---

在单级中断系统中，CPU一旦响应中断，则立即关闭（   ）标志，以防本次中断服务结束前同级的其他中断源产生另一次中断进行干扰。B  看看就好, A

A.中断允许

B.中断屏蔽

C.中断保护

D.中断请求

单级中断, 单重中断, 如果CPU在执行中断服务程序, 不理睬新的中断请求. CPU一旦响应了某中断源的请求后, 便由硬件线路自动关中断, 即中断允许触发器EINT被置0, 直到用开中断指令将EINT置为1才能再响应中断请求

---

通道对CPU的请求形式是（   ）。D

A.通道命令: 对具有通道的I/O系统专门设置的指令, 这类指令一般用以指明参与传送(写入或读取)的数据组在**主存**中的首地址; 指明需要传送的字节数或传送数据组的末地址; 指明所选设备的设备码及完成某种操作的命令码

B.自陷

C.跳转指令

D.中断

|      | 对CPU来说是 | 和当前CPU所执行的指令的关系 | CPU接下来的事情                                | 程序员和用户的态度       |                                                              |
| :--- | :---------- | :-------------------------- | :--------------------------------------------- | :----------------------- | ------------------------------------------------------------ |
| 中断 | 被动的      | 异步的                      | 没关系                                         | 跳转到对应的ISR          | 希望有对应的中断，以使得CPU可以响应对应的中断，执行对应的ISR |
| 异常 | 被动的      | 同步的                      | 有关系，因为就是当前指令执行出问题，才有的异常 | 跳转到对应的异常处理     | 不希望出现异常，如果出现了，那往往是指令执行出现某些错误了   |
| 陷阱 | 主动的      | 同步的                      | 有关系，就是执行当前软中断指令，才进入的软中断 | 执行对应的软中断处理函数 | 对于想要实现调试功能的程序员，有需要此陷阱的必要，其他人不用关心此点 |

![中断，陷阱和异常的区别](%E8%AE%A1%E7%BB%84.assets/interrput_trap_exception.png)

---

描述PCI总线中基本概念正确的句子是（   ）。ABC

A.桥的作用可使所有的存取都按CPU 的需要出现在总线上

B.PCI 总线体系中有三种桥，它们都是PCI 设备

C.HOST 总线不仅连接主存，还可以连接多个CPU

D.以桥连接实现的PCI总线结构不允许许多条总线并行工作



ISA: Industrial Standard Architecture 使用独立于CPU的总线时钟(CPU就可以用更高频的时钟), 不支持多台具有申请总线控制权的设备, ISA上所有的数据的传送必须通过CPU或DMA接口来管理



EISA: Extended Industrial Standard Architecture 支持多个总线主控器



PCI总线: Peripheral Component Interconnect 外围部件互连总线, 支持即插即用, 支持多主设备, PCI总线可视为**CPU与外设之间的一个中间层**, 通过PCI桥路(PCI控制器)与CPU相连, PCI桥路有多级缓冲, 可把一批数据快速写入缓冲器, 在这些数据不断写入PCI设备过程中, 可真正实现与处理器/存储器子系统的安全并发工作

PCI设备中不存在DMA的概念, 因为PCI总线支持无限的猝发式传送, 传统总线上用DMA方式工作的设备移植到PCI总线上时采用主设备工作方式即可

<img src="%E9%A2%98.assets/image-20200506173032713.png" alt="image-20200506173032713" style="zoom: 50%;" />

- CPU总线和PCI总线是隔开的, 以提高灵活性, 支持更多高速运行的设备(低速的挂在ISA, EISA总线上), 支持即插即用. 

<img src="%E9%A2%98.assets/image-20200506184230079.png" alt="image-20200506184230079" style="zoom:50%;" />

![image-20200506180435437](%E8%AE%A1%E7%BB%84.assets/image-20200506180435437.png)

HOST总线(CPU总线, 系统总线, 主存总线, 前端总线): 连接北桥芯片和CPU之间的信息通路

LAGACY总线: 可以是ISA, EISA, 支持中低速I/O设备

桥: 连接两条总线, 使彼此相互通信, 还可以把一条总线的地址空间映射到另一条总线的地址空间, 从而使任意一个总线主设备都能看到同样的一份地址表; 桥可以延迟写和预读, 使所有的存取都按CPU的需要出现在总线上

PCI总线体系结构中有三种桥(见上图):

- HOST桥: 是PCI总线控制器, 含中央仲裁器. 

[link_ppt](https://wenku.baidu.com/view/a281747bbdd126fff705cc1755270722192e5936.html?re=view)

---

一某中断系统中，每抽取一个输入数据就要中断CPU一次，中断处理程序接收取样的数据，并将其保存到主存缓冲区内，该中断处理需要X秒。另一方面，缓冲区内每存储N个数据，主程序就将其取出进行处理，这种处理需要Y秒。因此，该系统可以每秒跟踪(54)次中断请求。

A．N/(NX+Y)

B．N/(X+Y)N

C．MIN [1/X,1/Y]

D．MAX[1/X.1/Y]

输入N个数据，从缓冲区中存储到主程序将其取出需Y秒；每输入一个要中断一次，每个中断处理需X秒，则N个就是NX秒。所以跟踪Ⅳ次中断一共要花NX+Y秒，因此每秒跟踪M(NX+Y)次中断请求。代入具体数字更好理解

---

中断向量：中断服务程序的入口地址；中断向量地址：内存中存放中断服务程序入口地址的地址。

---

一台计算机对n个数据源进行分时采集，送入主存，然后分时处理。采集数据时，最好的方案是使用（   ）。D

A.堆栈缓冲区

B.两个指针的单缓冲区

C.一个指针的缓冲区

D.n个指针的n个缓冲区

---

如果机器采用中断方式进行输入和输出，发生中断请求条件的是（   ）。

机器内部发生故障

一次 I/O 操作结束

一次DMA 操作结束

一条指令执行结束

---

