线性代数围绕两种基本运算: 向量加法（vector addition）和标量数乘（scalar multiplication） 

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902213321094.png" alt="image-20200902213321094" style="zoom:50%;" />

# 线性组合

> linear combination 

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902214451681.png" alt="image-20200902214451681" style="zoom:50%;" />

为什么叫线性呢？如果你固定其中一个标量，让另一个标量自由变化，这两个向量合起来指向的终点会描出一条直线；如果让两个标量同时自由变化，就能够得到所有可能的向量。

为什么要定义基向量呢？随便找两个向量不就能表达任何向量了吗？因为如果这两个向量刚好共线或者是零向量就不妙了。

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902220704556.png" alt="image-20200902220704556" style="zoom:50%;" />

张成空间（span）：如果共线，span就是一条线

span其实就是仅通过vector addition和scalar multiplication这两种基础运算能获得的所有向量集合

# 线性相关

如果有3个**随机的**向量，这么这3个向量的组合能包含3维空间内的所有向量。

如果一个向量可以表示为其他向量的线性组合，因为这个向量已经落在向量张成空间中，那么它们**线性相关**。

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902221918056.png" alt="image-20200902221918056" style="zoom:50%;" />

如果所有向量都给张成空间添加了新的维度，那么这些向量**线性无关**。

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902221843556.png" alt="image-20200902221843556" style="zoom:50%;" />

# 线性变换

## 矩阵向量乘积

> linear transformation

线性变换需要具有以下两条性质：

1. all lines must remain lines, without getting curved. 
2. the origin must remain fixed in place. 

其实就是保持坐标网格线**平行且等距分布（parallel and evenly spaced），且原点保持不动**的变换。例子有如旋转坐标，剪切（Shear，就是将网格倾斜），拉伸或挤压坐标轴等

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902223900857.png" alt="image-20200902223900857" style="zoom:50%;" /><img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902223926593.png" alt="image-20200902223926593" style="zoom:50%;" />

$\begin{bmatrix} x \\ y \end{bmatrix}$ 表示在普通直角坐标系中（基向量是$\begin{bmatrix} 1 \\ 0 \end{bmatrix}$，$\begin{bmatrix} 0 \\ 1 \end{bmatrix}$）$x\cdot \begin{bmatrix} 1 \\ 0 \end{bmatrix} + y \cdot \begin{bmatrix} 0 \\ 1 \end{bmatrix}$ 后的向量

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902225439504.png" alt="image-20200902225439504" style="zoom: 50%;" />



<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902230303816.png" alt="image-20200902230303816" style="zoom:50%;" />

$\begin{bmatrix} 1 \\ 0 \end{bmatrix}$是新坐标的一个基向量，$\begin{bmatrix} 1 \\ 1 \end{bmatrix}$ 是另一个基向量，$\begin{bmatrix} x \\ y \end{bmatrix}$ 要从原来的普通直角坐标转成这个新的坐标，就只要乘以$\begin{bmatrix} 1&1 \\ 0&1 \end{bmatrix}$就可以了。



$\begin{bmatrix} 1&0 \\ 0&1 \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} x \\ y\end{bmatrix}$ 知道为什么结果是这样了吧？因为$\begin{bmatrix} 1&0 \\ 0&1 \end{bmatrix}$是普通的直角坐标系。



矩阵（如$\begin{bmatrix} 1&1 \\ 0&1 \end{bmatrix}$ ）可以看作是对空间的一种特定变换（transformation of space），而由于新坐标的网格线具有平行且等距分布，原点不动的性质，要想得到向量$\begin{bmatrix} x \\ y \end{bmatrix}$变换后的结果，只要让$x，y$乘以变换后的新的基向量（如$\begin{bmatrix} 1&1 \\ 0&1 \end{bmatrix}$ ）。



图中绿橙两个基向量是线性无关的，如果是线性相关，那就成一条直线了，如下面所示

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200902232742021.png" alt="image-20200902232742021" style="zoom:50%;" />

矩阵向量乘法就是计算**线性变换作用于给定向量**的一种途径。

## 复合变换，矩阵乘法

旋转和剪切（Shear）两种线性变换同时使用，就是“复合变换”。

$\begin{bmatrix} x \\ y \end{bmatrix}$乘以一个旋转后的新坐标，再乘以一个剪切后的新坐标，效果等同于直接乘以一个已经旋转剪切过的新坐标。

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903012422240.png" alt="image-20200903012422240" style="zoom:50%;" />

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903012431255.png" alt="image-20200903012431255" style="zoom:50%;" />

可以看出，两个矩阵相乘相当于对原坐标做了两次线性变换。建议每次计算矩阵乘法的时候可以想想这个。

BTW：$\begin{bmatrix} 0&-1 \\ 1&0 \end{bmatrix}$ 是旋转矩阵，原来的两个基坐标是(1, 0) (0, 1) ，变成了(0, 1) (-1, 0)，画下图就知道旋转了90°。	

注意，是先进行旋转，再进行剪切（从左到右），顺序不能乱

因为矩阵相乘的时候，顺序会影响结果。证明如下

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903081947903.png" alt="image-20200903081947903" style="zoom:50%;" /> <img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903082001628.png" alt="image-20200903082001628" style="zoom:50%;" />

将这两个动作叠加，顺序不同，结果不同。

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903014250066.png" alt="image-20200903014250066" style="zoom:50%;" />

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903014313792.png" alt="image-20200903014313792" style="zoom:50%;" />

整个证明过程不需要计算，是不是很神奇。

再来看一个证明题：$(AB)C=A(BC)$ 证明矩阵乘法符合结合律。

等式左边可以看作先执行$C$变换，再执行$AB$两个迭加变换；等式右边可以看作先执行C变换，再B变换，最后A变换。整个的顺序没有变，所以就应该相等。

## 3维空间

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903085203576.png" alt="image-20200903085203576" style="zoom:50%;" />

这种3个基向量互相垂直的坐标可以用$\begin{bmatrix} 1&0&0 \\ 0&1&0\\0&0&1\end{bmatrix}$表示，3个基向量的坐标分别是$(1,0,0)、(0,1,0)、(0,0,1)$

看一个比较复杂的例子

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903085958863.png" alt="image-20200903085958863" style="zoom:50%;" />

绕y轴旋转90°

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903090115067.png" alt="image-20200903090115067" style="zoom:50%;" />

向量和矩阵的乘法和二维空间的同理

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903093013153.png" alt="image-20200903093013153" style="zoom:50%;" />

矩阵和矩阵的乘法也和二维空间的类似

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903093206590.png" alt="image-20200903093206590" style="zoom:50%;" />

相当于两次坐标变换的复合。

# 行列式

[link](https://www.bilibili.com/video/BV1Qs41167bP)

## 2维空间

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903110659837.png" alt="image-20200903110659837" style="zoom:50%;" />

一个1*1的矩形在坐标发生变换后($\begin{bmatrix} 3&0 \\ 0&2 \end{bmatrix}$, 表示x轴拉伸3倍，y轴拉伸2倍)，就变成了下面这样。

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200903110042030.png" alt="image-20200903110042030" style="zoom:50%;" />

这个矩形的面积被拉伸了6倍，行列式算出来就是6。

**行列式能表示变换对空间拉伸或挤压了多少。**

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907125022963.png" alt="image-20200907125022963" style="zoom:50%;" /><img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907134005800.png" alt="image-20200907134005800" style="zoom:50%;" />



如果两个基坐标线性相关，那么这个平面就被压扁了

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907134205278.png" alt="image-20200907134205278" style="zoom:50%;" /><img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907134239742.png" alt="image-20200907134239742" style="zoom:50%;" />

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907134553903.png" alt="image-20200907134553903" style="zoom:50%;" />

如果是负的，那就要把坐标翻转，看，上面的橙色坐标跑到了绿色坐标的右边

### 计算

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907140840731.png" alt="image-20200907140840731" style="zoom:50%;" />

推导过程

![image-20200907140923928](%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907140923928.png)



## 3维空间

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907134949593.png" alt="image-20200907134949593" style="zoom:50%;" />

被压扁的情况

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907135159468.png" alt="image-20200907135159468" style="zoom:50%;" />

​	

### 计算

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907141053816.png" alt="image-20200907141053816" style="zoom:50%;" />



# 逆矩阵

先来看看这个

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907141532002.png" alt="image-20200907141532002" style="zoom:50%;" />

要计算这个二元一次方程，可以想象成是某个向量x经过矩阵A的变换后得到了向量v

这里的A要分成两种情况，一种是行列式为0，一种是不为0

- det(A) != 0

  - $A^{-1}A = \begin{bmatrix} 1&0 \\ 0&1 \end{bmatrix}$, $A^{-1}$是$A$的逆操作(inverse transformaiton)，x通过A变换得到v，那么v通过A的逆变换$A^{-1}$就得到x，方程得解：$\vec{x} = A^{-1}\vec{v}$

- det(A) == 0

  - 如果A的行列式为0的话，执行A变换后就降维了，也就没有逆变换，因为信息已经丢失，你无法将一个低维的东西解压缩为高维的。或者说这不是一个函数能做的（函数只有一个输入，一个输出，映射才能多个输出）

  - 一个函数不能将<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907145310544.png" alt="image-20200907145310544" style="zoom: 25%;" />转成这个<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907145233636.png" alt="image-20200907145233636" style="zoom: 25%;" />

  - 解

    <img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907145821420.png" alt="image-20200907145821420" style="zoom:50%;" />

    

# 秩

> rank
>
> 变换后空间的维数，列空间的维数

- 2*2矩阵的秩最大是2；3 * 3矩阵的秩最大为3，如果是2说明被压缩了

- 对于满秩变换来说，唯一能在变换后落在原点的就是零向量自身

  <img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907150722026.png" alt="image-20200907150722026" style="zoom:50%;" />

- 对于非满秩变换来说，它将空间压缩到一个更低的维度上

## 满秩

> full rank
>
> 秩等于列数



# 列空间

> column space
>
> <img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907152345493.png" alt="image-20200907152345493" style="zoom:50%;" />
>
> 列空间就是矩阵的列所张成的空间

- 零向量一定在列空间中

# 零空间

> Null space, kernel

# 点积

> Dot product

- 结果为[标量](https://zh.wikipedia.org/wiki/标量)

<img src="%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907154400625.png" alt="image-20200907154400625" style="zoom:50%;" />

![image-20200907154520457](%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907154520457.png)

![image-20200907154537842](%E7%BA%BF%E4%BB%A3%E7%9A%84%E6%9C%AC%E8%B4%A8.assets/image-20200907154537842.png)

如果两个向量的夹角小于90°，结果为正，夹角等于90°，结果为零，否则结果为负。

