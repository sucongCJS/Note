## 逻辑地址

段号:偏移

在实地址方式下, 上述段号是段值; 在保护方式下, 上述段号是段选择子

通过段号可以得到段起始地址, 加上偏移得到(物理地址)

### 实地址模式

- 缺陷: 每一个指针都是指向一个实在的物理地址, 很容易如果误修改, 可能会系统崩溃
- 实地址方式下, 每个段的长度不超过64KB

### 保护模式

- 

### 段寄存器

16位

不能把立即数直接传送到段寄存器

在保护模式下, 应用程序不宜改变段寄存器的值

- cs 指定当前代码段 **不能作为目标, 不能显式地改变段寄存器cs**
- ss 指定当前堆栈段
- ds 指定当前数据段
- es, fs, gs 附加段寄存器, 指定数据段

## 寻址方式

### 立即寻址方式

`mov eax,12345678H`

### 寄存器寻址方式

`mov ebp,esp`

### 直接寻址方式

`mov ,[8547CH],dx`

### 寄存器间接寻址方式

`mov eax,[esi]`

### 取有效地址

#### LEA

> load effective address

`mov ebx,edi+4`是把对应存储单元的内容传送到寄存器ebx

`lea ebx,[edi+4]`是把对应存储单元的有效地址传送到存储器ebx, `edi+4`被当作地址, 加上`[]`变成值

## 标志寄存器

| 状态标记               |      |
| ---------------------- | ---- |
| CF Carry Flag | 运算结果的最高位产生进位或借位, 置1, 否置0 |
| ZF Zero Flag           | 运算结果为0, 置1, 否置0 |
| SF Sign Flag           | 与运算结果的最高位相同 (无论有无符号数) |
|OF Overflow Flag|有符号数加减溢出 溢出置1|
|PF Parity Flag|最低字节中含有的"1"的位数, 偶数个置1, 否置0|
|AF Auxiliary Carry Flag|最低的4位是否有进位或借位, 有置1, 否置0|



## 指令指针寄存器

实地址方式下, 段的最大范围是64K, 所以EIP的高16位为0, 只有低16位的IP起作用

条件转移的目的地仅限于同一段代码段内 **段内转移**

## 堆栈

入栈: ESP先减, 数据入栈

出栈: 数据出栈, ESP再加

栈底在高地址处

### 作用

- 保存寄存器内容或保护现场
- 保存返回地址
- 传递参数
- 安排局部变量或临时变量

# 程序设计初步

## 过程

> procedure

C语言中的子程序就是汇编中的过程                                                                                       

子程序与无条件转移的区别是调用子程序要考虑返回

## 过程调用

主程序 -> 子程序

步骤:

1. 保存返回的地址: 把返回地址压入堆栈
2. 转移到子程序的入口地址: 使EIP等于子程序开始处的地址偏移

## 参数传递

通过堆栈传递入口参数步骤:

1. 主程序先把入口参数压入堆栈, 
2. 然后利用call指令调用子程序
   1. 调用指令call把返回地址偏移压入堆栈
   2. 进入子程序
      1. 先把寄存器EBP压入堆栈
      2. 把堆栈指针寄存器ESP的值送入到EBP, 现在就可以方便地取出参数了 (建立堆栈框架)
   3. 返回主程序之前从堆栈弹出刚才保存的EBP值, 恢复EBP (撤销堆栈框架)
3. ret, 返回到主程序main, 从堆栈弹出返回地址偏移
4. 调整堆栈指针寄存器ESP的值, 达到平衡堆栈的目的

# 指令

## neg

取补指令, 取负数指令

对操作数取补, 即取反加一

## mov

> MOV DEST, SRC

两操作数的尺寸必须一致

## push

32位, 至少入栈一个字

## XCHG

两操作数的尺寸必须一致

## SUB

两操作数的尺寸必须一致







