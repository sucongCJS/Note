# 模式

逻辑地址

段号:偏移

在实地址方式下, 上述段号是段值; 在保护方式下, 上述段号是段选择子

通过段号可以得到段起始地址, 加上偏移得到(物理地址)

## 实地址模式

- 缺陷: 每一个指针都是指向一个实在的物理地址, 很容易如果误修改, 可能会系统崩溃
- 实地址方式下, 每个段的长度不超过64KB
- 32位兼容16位的做法

## 保护模式

# 寻址方式

## 立即数寻址方式

> 操作数本身就包含再指令中, 直接作为指令的一部分给出

`mov eax,12345678H`

## 寄存器寻址方式

> 操作数再CPU内部的寄存器中, 指令中指定寄存器

`mov ebp,esp`

- 专用寄存器不能用 IP, FLAG

## 直接寻址方式

> 操作数在存储器中, 指令直接包含操作数所在的存储单元的有效地址

- `mov [8547CH],dx`

- `mov ecx, [82632H]`

- `mov ax, x`; 符号地址x必须事先定义  = `mov ax, [x]`
  - x dw 100h
  - 在汇编中最好把变量理解成数据存储的地址 比如, x的地址是4010h, 4010h处存的值是100h, mov ax, x其实就是 mov ax, [x] , 所以ax存的是x的值 100h

- `mov ax, es:[100H]` ; **段超越前缀**的方式来改变默认段寄存器

## 寄存器间接寻址方式

> 操作数在存储器中, 由8个32位的通用寄存器之一给出操作数所在存储单元有效地址
>
> 
>
> 通过存储器给出存储单元有效地址的

`mov eax,[esi]`

`mov [edi], ci`

## 寄存器相对寻址方式

> 操作数在存储器中, 操作数的有效地址是一个基址寄存器(BX, BP) 或变址寄存器(SI, DI) 内容加上指令中给定的8位或16位位移偏移量

- mov ax, 1[bx]

- mov bx, [bp-4]

  引用的段寄存器是ss

- mov ax, [di+1223h]

  引用的段寄存器是ds

## 基址变址寻址方式

> 基址寄存器+变址寄存器
>
> 必须一个基址寄存器和一个变址寄存器

mov ax, [bx+di]

如果是bx, 没说的话用的是ds段



mov ax, [bp+di]

如果是bp, 没说的话用的是ss段



`mov ax, [bx][si]`

## 相对基址变址寻址方式

- mov ax, [bx+di-2]

- mov ax, [bx+di+1234h] =  mov ax, 1234h[bx + di]

## 取有效地址

### LEA

> load effective address

`mov ebx,edi+4`是把对应存储单元的内容传送到寄存器ebx

`lea ebx,[edi+4]`是把对应存储单元的有效地址传送到存储器ebx, `edi+4`被当作地址, 加上`[]`变成值

# 堆栈

入栈: ESP先**减**, 数据入栈

出栈: 数据出栈, ESP再加

栈底在高地址处

### 作用

- 保存寄存器内容或保护现场
- 保存返回地址
- 传递参数
- 安排局部变量或临时变量

# 程序设计

## 过程

> procedure

C语言中的子程序就是汇编中的过程                                                                                       

子程序与无条件转移的区别是调用子程序要考虑返回

## 过程调用

主程序 -> 子程序

步骤:

1. 保存返回的地址: 把返回地址压入堆栈
2. 转移到子程序的入口地址: 使EIP等于子程序开始处的地址偏移

## 参数传递

通过堆栈传递入口参数步骤:

1. 主程序先把入口参数压入堆栈, 
2. 然后利用call指令调用子程序
   1. 调用指令call把返回地址偏移压入堆栈
   2. 进入子程序
      1. 先把寄存器EBP压入堆栈
      2. 把堆栈指针寄存器ESP的值送入到EBP, 现在就可以方便地取出参数了 (建立堆栈框架)
   3. 返回主程序之前从堆栈弹出刚才保存的EBP值, 恢复EBP (撤销堆栈框架)
3. ret, 返回到主程序main, 从堆栈弹出返回地址偏移
4. 调整堆栈指针寄存器ESP的值, 达到平衡堆栈的目的

**_cdecl**被称为 C 调用约定。缺省调用约定。参数按照从右至左的顺序入堆栈，函数本身不清理堆栈。
**_stdcall**被称为 pascal 调用约定。参数按照从右至左的顺序入堆栈，函数自身清理堆栈。
**_fastcal**l 是快速调用约定。通过 寄存器传递参数。前两个参数由 ECX 和 EDX 传送，其他参数按照从右至左的顺序入堆栈，函数自身清理堆栈。

# 操作符

## offset

[link](http://www5.zzu.edu.cn/qwfw/info/1032/1789.htm)

offset后面只能跟变量

取地址



与lea的区别

- lea bx, buffer 执行的时候才会将buffer的地址给bx
- mov bx, offset buffer 编译的时候就计算好buffer的地址(假设为4300), 然后语句变为 mov bx, 4300
- 所以lea可以进行复杂的计算, 如 lea eax, [esi+ebx*4], 但是mov不行, 如mov bx, offset [bx+200]是错误的
  - OFFSET只能取得用 ”数据定义伪指令” 定义的变量的有效地址,不能取得一般操作数的有效地址(摘自80x86汇编语言程序设计教程)
  - mov ax, [4300H + 200] 可以运行, 地址加偏移, 所以不能说因为在汇编的时候将变量的值计算出来, 而导致 mov bx, offset [buffer + 200] 错误

## $

当前地址

# 指令

## 伪指令

> 包括**数据定义**语句和**存储单元定义**语句
>
> 
>
> 数据定义语句: 定义初始化的数据项
>
> 存储单元定义语句: 定义初始化的数据项

- 没有目标代码

### ptr

- 当只有一个存储器操作数时, 这个操作数的类型是不明确的, 必须使用类型说明

- example
  - `dec [bx]` → `dec byte ptr [bx]`   or  `dec word ptr [bx]` 

### org

数据段

起始地址，源。在汇编语言源程序的开始通常都用一条*ORG*伪指令来实现规定程序的起始地址

### dup

`var dw 5 dup(?)` 预留5个字长度的空间, (赋为0)

## 逻辑指令

| 指令     | 效果                 | 标志位                           | 应用场景                                                     |
| -------- | -------------------- | -------------------------------- | ------------------------------------------------------------ |
| NOT 否   | 取反                 | 不影响标志位                     |                                                              |
| AND 与   | 同时为1, 则为1       | CF=0, OF=0, 其他按情况变(AF除外) | 用在使一个操作数的若干位保持不变, 另外若干位清零 (保持不变的设置1, 清零的设置0); 自己和自己与, 使进位标志清零 |
| OR 或    | 同时为0, 才为0       | CF=0, OF=0, 其他按情况变(AF除外) | 自己和自己或, 使进位标志清零;                                |
| XOR 异或 | 不同设为1, 相同设为0 | CF=0, OF=0, 其他按情况变(AF除外) | 清零寄存器;                                                  |

## 移位指令

### 一般移位指令

#### SAL SHL

> SHift Arithmetic Left
>
> SHift logic Left

操作数左移, 右边用0补足, 移出的**最高位**进入标志位CF

#### SAR

>  Shift Arithmetic Right

操作数右移, 左边的符号位保持不变, 移出的**最低位**进入CF

即如果符号位是1, 用1补, 符号位是0, 用0补, 达到不管是正还是负, 都表示**除n个2**

#### SHR

> SHift logic Right

用0补足, 最低位进入CF

### 循环移位指令

#### ROL

## 字符串指令

### LODSB  LODSW LODSD

不影响状态标志

相当于:

```assembly
mov al, [esi]
inc esi 

mov ax, [esi]
add esi,2

mov eax, [esi]
add esi, 4
```

### STOSB

mov [edi], al

inc edi

### STOSD

mov [edi], eax

add edi, 4

### MOVSB

lodsb

stosb

类似: movsw, movsd

### CLD STD

修改DF

DF为零: 从低到高, 每次加1, 或2, 或4

DF为一: 从高到低, 每次减1, 或2, 或4

## 转移指令

### 段间转移

> 修改IP, CS

#### 段间直接转移

- jmp codeB:step
  - codeB 是转移目标段
  - step 是目标端内偏移

- jmp far step
  - far 可省略
- jmp far prt DONE
  - DONE是指针, 即地址

#### 段间间接转移

- ptnext dw step ; step的偏移

  ​			 dw code ; step 所在段的段值

  **jmp far [ptnext]**

- mov bx, ptnext ; 

  **jmp far [bx]**

  - 实方式下, ptnext是双字存储单元, 低16位给IP, 作偏移, 高16位给CS, 作段值; bx应为ebx 

### 段内转移

#### 段内直接转移

- jmp step

#### 段内间接转移

- lea edx step

  jmp edx

- lea eax step

  mov intVar, eax

  jmp intVar

### 条件转移

#### 无符号

above, below

- ja,  jna, jae, jnae
- jb,  jnb, jbe, jnbe

#### 有符号

greater, less

- jg, jng, jge, jnge
- jl,  jnl,  jle,  jnle

---

## add

## adc

## dec

该指令不影响进位标志(CF)

## neg-

取补指令, 取负数指令

对操作数取补, 即取反加一

如果操作数为0, 那么使得进位标志(CF)为0, 否则进位标志为1

## mov

### mov

> MOV DEST, SRC

非法指令情况

[link](http://www5.zzu.edu.cn/qwfw/info/1030/1750.htm)

#### 错误指令

- 两操作数的类型不一致, 如 `mov al, 059AH`

- mov bx, offset [bx+200], 详见offset

- .Data 

  ​	WordVar dw 2 dup(?)

  ​	ByteVar   db  ?

  .Code

  ​	mov al, ByteVar - WordVar

  **内存地址不能相加, 只能相减**

  (相减代表两段内存的相位差, 相加结果没意义, 还可能回造成溢出)

- mov [bx], 2000H

  缺少修饰符, 如word ptr, 改为:

  mov word ptr[bx], 2000H

- 两个操作数同时位存储器的情况也不可以

- 段寄存器

  - mov ds, 100H

    段寄存器属于专用寄存器, 操作能力有限不能用立即数传值

  - mov cs, [si]

    不能显式地改变cs的值, 见cs

  - mov ds, es

    不允许段寄存器之间传送



### movsx

> move with sign-extension

符号扩展传送指令, 最高位1则f	

### movzx

零扩展传送指令

源操作数可以是8, 16位, 目的操作数只能是16, 32位

## push

- 32位, 至少入栈一个字
- 16位: 指令操作数不能是立即数, 32位可以
- DST 隐含, SS:SP指定

## XCHG

> 将指定的两个操作数交换

- 两操作数的尺寸必须一致

- 操作数不能是段寄存器

## SUB

> sub dest, src
>
> dest = dest - src

两操作数的尺寸必须一致

## MUL

乘积尺寸翻倍

## IMUL

> IMUL DEST * SRC

DEST只能是16位或32位通用寄存器

SRC可以是通用寄存器, 存储单元, 立即数

## CBW

将AL中的符号位扩展到AH, 若AL的最高位为1, 把FFH存入AH, 否则把00H存入AH

## INC

不影响标志寄存器中的进位标志(CF), 但会影响其他状态标志 (因为**该指令主要用于指针进行增加, 不存在进位问题**)



## DEC

不影响标志寄存器中的进位标志(CF), 但会影响其他状态标志

## sizeof

`size of 变量名`: 计算变量定义的字节空间个数

计算**数组长度**(数组占用内存的总长度)

如果是数组, 等于 元素个数 * 元素的大小

例如: 

`dvar	dd	1,2,3`

sizeof dvar = 0ch

## lengthof

`lengthof 变量名`: 计算的是该变量本身定义的空间个数, 该空间可能是字空间, 也可能是字节空间

数组元素的个数

## type

`type 变量名`: 分离出其后变量或标号的类型的值

- DB(字节) 为1
- DW(字) 为2
- DD(双字) 为4
- DF(六字节的字) 为6
- DQ(四字) 为8
- DT(10字节) 为10

## even

使下一个变量或指令开始存储于偶数字节地址

## cdq

> convert doubleword to quadword

把寄存器eax中的符号扩展到寄存器edx, 

即若eax的最高位有效位为0, 则edx=0; 若eax的最高位有效位为1, 则edx = 0ffffffffh(0的反码)

## xor

逻辑异或

- 可用于给无符号数扩展符号位, 直接清0 例如: `xor edx, edx`, 除法运算扩展乘64位

## div

`div esi`: eax = eax / esi ……edx

`div OPRD`

- 如果OPRD是字节: AX / OPRD = AL ...... AH
- 如果OPRD是字: DX:AX / OPRD = AX ...... DX (被除数的高16存放于DX, 低16位存放于AX)
- 如果OPRD是双字: EDX:EAX / OPRD = EAX ...... EDX (被除数的高32位存放在EDX)

## idiv

`idiv cl` ; 被除数在ax中, 商在al, 余数在ah

`idiv bx` ; 被除数在ax中, 商在ax, 余数在dx

## CMP

减法

## test

把两个操作数进行按位"与", 但结果不送到目的操作数, 仅仅影响状态标志, CF,OF清零, ZF, PF, SF也会变

```assembly
test eax, eax
jne SHORT LL3cf320
.......
test eax, eax
jle SHORT anotherplase ; eax<=0跳转
; jle跳转的条件: ZF=1或者SF!=OF
; 如果eax是负数: ZF=0, OF=0, CF=0, SF=1(eax的第一位是1) 
```

## ret

ret count 返回, 顺便平衡堆栈

## rep

先判断ecx是否为0, 如果为0就结束重复, 否则ecx减一, 再重复后面的操作

不影响状态标志

## aaa

> ASCII adjust after addition
>
> 是BCD指令集中的一个指令, 用于在两个未打包的BCD值相加后, 调整al和ah寄存器的内容

### BCD

> Binary-cod decimal
>
> 2进制码的十进制数, 占一个字节的低4位, 只有0-9是有效值

## LDS/LES

?

# 寄存器

## 通用寄存器

- 32位: EAX EBX ECX EDX ESI EDI EBP 没有ESP
- 16位: AX BX CX DX SI DI BP SP
- 8位: AL AH BL BH CL CH DL DH 没了

## 间址寄存器

- 只有间址寄存器可以出现在方括号里 !
  - mov bx, [ax] 错误

### 基址寄存器

- BX, BP

### 变址寄存器

- SI, DI

## 指令指针寄存器

实地址方式下, 段的最大范围是64K, 所以EIP的高16位为0, 只有低16位的IP起作用

条件转移的目的地仅限于同一段代码段内 **段内转移**

## 标志寄存器

| 状态标志位              |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| CF Carry Flag           | 运算结果的最高位产生进位或借位, 置1, 否置0<br/>无符号数可以把CF作为溢出标志 |
| ZF Zero Flag            | 运算结果**为0, 置1**, 否置0                                  |
| SF Sign Flag            | 与**运算结果**的最高位相同 (无论有无符号数)                  |
| OF Overflow Flag        | **有符号数**加减溢出 <br/>正正得负, 或者负负得正置1, 其他情况置0 |
| PF Parity Flag          | 最低字节中含有的"1"的位数, 偶数个置1, 否置0                  |
| AF Auxiliary Carry Flag | 最低的4位是否有进位或借位, 有置1, 否置0                      |

默认是当成无符号数

| 控制标志位        |                          |
| ----------------- | ------------------------ |
| DF Direction Flag | 0: 由低到高, 1: 由高到低 |
|                   |                          |

清零标志位CLC：CF <- 0
置位标志位STC：CF <- 1 

### 溢出和进位的区别

- 无论CF位何值, 无符号数的运算结果均正确, 因为使用CF, 变成了9位
- OF=1, 有符号数的运算结果不正确

## 段寄存器

16位

不能把立即数直接传送到段寄存器

在保护模式下, 应用程序不宜改变段寄存器的值

- cs 指定当前代码段 
  - **不能作为目标, 不能显式地改变段寄存器cs**
- ss 指定当前堆栈段
- ds 指定当前数据段
- es, fs, gs 附加段寄存器, 指定数据段

## 堆栈

- ebp寄存器 栈底指针, 通过 ebp+偏移量 可以访问call里边的局部变量. 低16位叫bp

- esp寄存器 栈顶指针, 与ebp构成一段空间的大小, 一般就是call局部变量的空间大小总和. 

- 每个call会分配一个独立的栈段空间, 供局部变量使用

- call栈平衡, 进call前和出call后, esp, ebp的值不变



# 中断

## int 16

https://blog.csdn.net/qingkongyeyue/article/details/68490194

| AH   | 功能                                                 | 入口参数 | 出口参数                                                     |
| ---- | ---------------------------------------------------- | -------- | ------------------------------------------------------------ |
| 0    | 从键盘读入字符送AL寄存器                             | 键盘输入 | 一旦输入，字符的ASCII码放入AL中。若AL＝0，则AH为输入的扩展码 |
| 1    | 用来查询键盘缓冲区，对键盘扫描但不等待，并设置ZF标志 | 无       | 若有按键操作（即键盘缓冲区不空），则ZF＝0，AL中存放的是输入的ASCII码，AH中存放输入字符的扩展码。若无键按下，则标志位ZF＝1 |
| 2    | 检查键盘上各特殊功能键的状态                         |          |                                                              |

## int 21

https://blog.csdn.net/richievoe/article/details/8235873

| AH      | 功能                              | 入口参数                             | 出口参数       |
| ------- | --------------------------------- | ------------------------------------ | -------------- |
| **4CH** | 返回DOS                           | 无                                   | 无             |
| **1**   | 键盘输入一个字符到AL中            | 无                                   | AL=字符        |
| **2**   | 输出DL寄存器的字符到显示器        | DL（存放一个字符）                   | 无             |
| **9**   | 输出一个以“$”结尾的字符串到显示器 | DS:字符串所在的段地址DX:字符串首地址 | 无             |
| **0AH** | 从键盘输入一个字符串到指定缓冲区  | DS:缓冲区所在的段地址DX:缓冲区首地址 | 缓冲区相应位置 |

# 问题

- 有效地址应为16位, 多于16位应按64K取模



- 地址 bx+90H 错误, 应为[bx+90H]
- 地址si[100H]错误, 应为100H[si]
- 通用寄存器作为间址寄存器 32位