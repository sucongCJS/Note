# 总

## 编译程序

- 编译程序：高级语言程序 -> 低级语言程序

  ![image-20201001082722341](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201001082722341.png)

- 解释程序：源语言程序 -> 边解释边执行

  <img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201001082736367.png" alt="image-20201001082736367" style="zoom:50%;" />

- 翻译程序：源语言(一种语言) -> 目标语言(另一种语言)

- 汇编程序：汇编语言程序 -> 机器语言程序



- 编译和解释的主要区别是：是否产生目标代码

## 编译过程

1. 词法分析：识别单词
2. 语法分析：分析句子语法结构
3. 语义分析，中间代码产生：根据句子含义初步翻译
4. 优化：修饰译文
5. 目标代码生成：写出最后译文

![image-20200930235456186](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20200930235456186.png)

- 预处理器：把存储在不同文件中的源程序聚集在一起；把称为宏的缩写语句转化为原始语句
- 可重定位（Relocatable）：在内存中存放的起始位置L不是固定的
- 链接器：将多个可重定位的机器代码文件（包括库文件）连接到一起。解决外部内存地址问题
- 加载器：修改可重定位地址；将修改后的指令和数据放到内存中适当的位置



## 编译程序结构

![image-20201001085143047](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201001085143047.png)

### 表格管理

- 编译各阶段都要涉及到构造、查找或更新有关表格 。
  - 表格的作用：登记源程序的各类信息和编译各阶段的进展状况。
  - 符号表：用来登记源程序中出现的每个名字以及名字的各种属性。

### 出错处理

- 每一阶段都可能检测出错误，绝大多   数错误可在前三阶段检测出来。

  -  任务：设法发现错误，并把有关错误信息报告给用户 

  - 语法错误：源程序中不符合语法/词法规则的错误。

    词法/语法分析时检测

  - 语义错误：源程序中不符合语义规则的错误。

    语义分析/运行时检测出来

### 遍

> Pass
>
> 对源程序或源程序的中间结果从头到尾扫描一次，并作有关的加工处理，生成新的中间结果或目标程序。

- 上述划分的五个阶段仅仅是逻辑功能上的一种划分，具体实现时，受各方面（如源语言、设计要求等）限制，往往组织成若干**遍**

- 既可以将几个不同阶段合为一遍，也可以把一个阶段的工作分为若干遍，例如

  词法分析+语法分析：一遍

  语法分析+语义分析与中间代码产生：一遍

  优化：若干遍（根据系统资源的状况、运行目标的要求等，可以将一个编译程序设计形成多遍扫描的形式，在每一遍扫描中完成不同的任务。）

- 当一遍中包含若干阶段时，各阶段的工作是穿插进行的。

### 编译前后端

前端：

- 由与源语言有关但与目标机无关的那些部分组成
- 包括——词法分析、语法分析、语义分析与中间代码产生、部分代码优化工作 

后端：

- 包括编译程序中与目标机有关的那些部分，如与目标机有关的代码优化和目标代码生成等。
- 不依赖于源语言而仅仅依赖于中间语言



## 编译程序环境

略略略

## 编译程序的生成

![image-20201001091212316](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201001091212316.png)

# 词法分析

> **规则**：依循词法规则
>
> **规则描述工具**：正规式、有限自动机（FA）
>
> **任务**：输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词符号，如基本字、标识符、常数、算符、界符等

- 词法规则——单词符号的形成规则，即规定了字母表中哪样的字符串是一个单词符号。
  - 单词符号——语言中具有独立意义的最基本结构。

## 基本概念

![image-20201001094136658](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201001094136658.png)

![image-20201001094506447](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201001094506447.png)

![image-20201001094701447](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201001094701447.png)

## 词法分析器

- 功能：输入源程序，输出单词符号
- 单词符号的分类
  - **关键字**：由程序语言定义的具有固定意义的标识符，也称为**保留字**或基本字。例如：Pascal 语言中 begin  end if while 等。
  - 标识符：用来表示各种名字。如变量名、数组名、过程名等。
  - 常数：整型、实型、布尔型、文字型等。例：100  3.14159  true  sample
  - 运算符：+、-、*、/
  - 界符：　，　；　（　　）等

### 设计

#### 预处理

> 剔掉空白符、跳格符、回车符、换行符、注解部分等.

预处理子程序：每当词法分析器调用时，就处理出一串确定长度（如120个字符）的输入字符，并将其装进词法分析器所确定的扫描缓冲区中。

![image-20201002092225482](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002092225482.png)



#### 识别单词符号

超前搜索

 1．关键字的识别

 2．标识符的识别

 3．常数的识别

 4．算符和界符的识别

#### 状态转换图

- ch	字符变量，存放最新读进的源程序字符。
- strToken	字符数组，存放构成单词符号的字符串。
- GetChar	子程序过程，将下一输入字符读到ch中，搜索指示器前移一字符位置。
- GetBC	子程序过程，检查ch中的字符是否为空白。若是， 则调用GetChar直至ch中进入一个非空白字符。
- Concat	子程序过程，将ch中的字符连接到strToken之后.
- IsLetter和IsDigit	  布尔函数过程，它们分别判断ch中的字符是否为字母和数字。
- Reserve	整型函数过程，对strToken中的字符串查找保留字表，若它是一个保留字则返回它的编码，否则返回0值（假定0不是保留字的编码）。
- Retract  子程序过程，将搜索指示器回调一个字符位置，将ch置为空白字符。
- InsertId	整型函数过程，将strToken中的标识符插入符号表，返回符号表指针。
- InsertConst  整型函数过程，将strToken中的常数插入常数表，返回常数表指针。

![image-20201002173219807](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002173219807.png)



## 规则描述工具



### 正规表达式

#### 正规式&正规集

![image-20201002093358304](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002093358304.png)

- |（或）：表示从各选择对象中选择

- ·（连接）：表示“连接”起来

- *（闭包）：任意有限次的自重复连接　　

  优先级：* > · > |

例子

![image-20201002105129577](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002105129577.png)



一个正规式的正规集与之完全等价，只是表达形式不同

若两个正规式所表示的正规集相同，则认为二者等价：两个等价的正规式Ｕ和Ｖ，记为Ｕ＝Ｖ

##### 例题

![image-20201002171828207](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002171828207.png)

![image-20201002105733536](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002105733536.png)

### 有限自动机

![image-20201002174258838](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002174258838.png)

#### DFA

> Deterministic Finite Automata 确定有限自动机

![image-20201002172415564](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002172415564.png)

![image-20201002173219807](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002173219807.png)

- 整张状态转换图含有唯一一个初态节点和若干个（可以是0个）终态节点。

![image-20201002172751605](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002172751605.png)

![image-20201002172956746](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002172956746.png)

#### NFA

> 非确定有限自动机

![image-20201002174236768](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002174236768.png)

1. 每条弧用 **∑*中一个字（可以是空字ε）**作为**输入字**
2. 箭弧上的标记 **允许** 相同。
3. 整张图至少含有一个初态结点以及**若干个**（可为0个）终态结点
4. 某些结点既可为初态结点也可为终态结点

# 语法分析

> **规则**：依循语法规则
>
> **规则描述工具**：上下文无关文法
>
> **任务**：在词法分析的基础上，根据语言的语法规则，对单词符号串进行语法分析，识别出各类语法单位，最终判断输入串是否构成语法上正确的“程序”。

- 语法规则——语法单位的形成规则，即规定了如何从单词符号形成更大的结构（即语法单位）。

## 上下文无关文法

> 文法：语法规则

上下文无关文法$Ｇ$的形式定义：$Ｇ$是一个四元组（$Ｖ_Ｔ$，$Ｖ_Ｎ$，$Ｓ$，$Ｐ$）

- $Ｖ_Ｔ$： 终结符号集，非空有限集

  - 终结符号：描述单词符号，组成语言的基本符号，是一个  语言的不可再分的基本符号。
  - 例如：基本字，标识符，常数，算符，界符等
- $Ｖ_Ｎ$：非终结符号集，非空有限集
  - $V_N\cap V_T = \emptyset$
  - 非终结符：代表语法范畴，一个非终结符代表一个一定的语法概念，每个非终结符表示一定符号串的集合。
  - 例如：算术表达式，布尔表达式，赋值句，分程序，过程等．
- $S$：开始符号，一个特殊的非终结符号
- $P$：产生式集合，有限集
  - 产生式：定义语法范畴的一种书写规则
  - 形式：$A\to \alpha A\in V_N,\alpha \in(V_T \cup V_N)*$

注：

- $\to$：定义为
- |：或
- 非终结符：用大写字母或汉语组代表
- 终结符：用小写字母代表
- ![image-20201002082033391](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002082033391.png)

## 语言

句型，句子，语言

![image-20201002081831103](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20201002081831103.png)

## 最左/右推导

> 任何一步α ⇒β都是对α中的最左／最右非终结符进行替换的

### 二义文法

> 用若一个文法中存在某个句子，它有两个不同的最左/右推导，则该文法为二义文法

## 语法分析树

> 用树的形式表示一个句型的推导生成，有助于理解一个句子语法结构的层次。

- 树根：开始符号
- 中间结点：非终结符
- 叶结点：终结符／非终结符

# 语义分析&中间代码产生

> **规则**：语义规则
>
> **规则描述工具**：属性文法
>
> **任务**：对语法分析器识别出的各类语法单位，分析其含义并进行初步翻译（产生中间代码）。 
>
> **两部分工作**：
>
> 1. 对每种语法范畴进行静态语义检查
> 2. 若语义正确，则进行中间代码翻译



# 优化

> **规则**：等价变换规则
>
> **任务**：对中间代码进行加工变换，以期在最后阶段 能产生出更为高效（省时间和空间）的目标 代码。 包括：公共子表达式的提取、循环优化、删除无用代码等

# 目标代码生成

> **规则**：
>
> **规则描述工具**：
>
> **任务**：把中间代码变换成特定机器上的低级语言代码（绝对指令代码/可重定位的指令代码/汇编指令代码），实现最后的翻译。