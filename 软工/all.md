# 软件

> 计算机系统与硬件相互依存的另一个重要部分
>
> 包括程序, 数据, 文档

## 特点

## 软件危机

> 开发时间大大超过预期, 导致资金浪费, 甚至人员伤亡 

- 表现
  - 对软件开发**成本和进度**的估计不准确
  - 对"已完成"系统**不满意**的现象
  - **质量**得不到保证
  - **可维护程度**低
  - 软件成本在计算机系统总成本中所占比例逐年上升
  - (部分可作为软件工程的出现的背景)

## 软件工程

> 运用**技术**措施(方法和工具)和**组织管理**措施来解决软件危机, 更好地**开发和维护软件**的一门学科

- 出现背景
  - 想要**经济地**获得能够**高效运行**的可靠软件

### 研究内容

> 软件工程三要素

​	<img src="all.assets/image-20200103132958119.png" alt="image-20200103132958119" style="zoom:67%;" />

- **工具**(层)
  - 为软件工程方法提供一个**软件支撑环境**
- **方法**(层)
  - 为软件开发的各个阶段提供方法
  - eg. 项目计划与估算方法, 需求分析和设计方法, 编程, 测试方法, 维护方法
- **过程**(层)
  - 将**方法和工具结合**起来
  - 定义一组**关键过程**区域的框架
  - 定义**方法使用的顺序**, 要交付的文档资料, 管理, 里程碑

### 目标

> 组织实施工程项目, 并最终希望得到项目的成功

- 付出较低的开发**成本**
- 达到所需的软件**功能**
- 取得较好的软件**性能**
- 开发的软件易于**移植**
- 需要较低的**维护**费用
- 能按**时**完成开发工作, 及时交付使用

### 原则

- 抽象
- 信息隐蔽(封装) 
- 模块化
  - 松耦合
- 局部化
  - 高内聚
- **确定性**
  - 所有概念表达应该是确定的, 无歧义的
- **一致性**
  - 程序, 文档, 数据的各个模块一致
  - 符号, 术语, 接口一致
- **完备性**
  - 达到系统功能要求
  - 需要严格的计数评审
- **可验证性**
  - 自顶向下逐层分解, 分解应遵循系统易于检查, 测试, 评审的原则
  - 一致性, 完备性, 可验证性保证系统的正确

## 软件生命周期!

### 定义

- **问题**定义
- **可行性**分析: 经济, 技术方面, 在尽可能短的时间内确定要不要做
- **需求**分析: 需求规格说明

### 开发

- 概要设计
  - 怎样实现目标系统
  - 设计多个方案, 选出最优方案
- 详细设计
  - 方法: 结构化程序设计
  - 以一种抽象概括的方式给出解决问题的方法
  - 蓝图, 包括必要细节
  - 对每个模块进行设计, 确定算法, 数据结构
- 编码和单元测试
- 综合测试
  - 集成测试
  - 验收测试: 按照需求规格说明验收

### 运行和维护

- 完善性维护: 新扩充功能, 改进性能
- 适应性维护: 适应环境的变化
- 改正性维护: 软件错误
- 预防性维护: 为将来的维护工作预先准备

## 软件过程模型

### 瀑布模型

- 特点：规定了工程活动自上而下、相互衔接的固定次序。
  - 当前活动接受上一项活动的工作结果
  - 产生本项活动的相关产出，作为输出传给下一项活动
  - 软件开发的各项活动严格按照线性方式进行
  - 当前活动的工作结果需要进行评审, 确认后才能进行下一项
- 适用于
  - 传统软件工程
    - 需求确定, 需求随时间变化小 (eg. 高铁轨道控制软件)
    - 对软件质量要求高 (eg. 卫星发射系统)
  - 开发技术成熟、工程管理比较严格的场合
- 缺点
  - 固化, 死板
  - 不能回滚, 改需求的话就意味着前功尽弃
  - 难以应对市场变化
- 优点
  - bug少

### 螺旋模型

- 特点
  - 使用**原型**等其他方法来尽量降低**风险**
- 适用于
  - 大型软件开发

### 喷泉模型

- 特点
  - 迭代性
    - 一旦在后面的阶段发现前阶段隐留的错误, 应返回前一阶段纠错
  - 无间隙性
    - 各个阶段相互重叠多次反复
    - 文档管理困难: 可以结合瀑布模型
- 适用于（需要结合其他模型）

### 增量模型

- 特点
  - 一旦一个增量构建已完成开发, 就可以交付使用
  - 用户对当前增量构件的反馈可以被纳入下一个增量
  - 较短时间内，向用户提交可完成部分工作的产品
  - 逐步增加产品功能，减少一个全新的软件可能给客户组织带来的冲击, 逐步适应
- 适用于
  - 软件体系结构必须是开放的, 便于扩充

### 原型模型

- 两个策略的特点
  - 废弃策略
    - 先构建一个原型系统(功能简单, 性能不高)
    - 根据用户反馈进行分析改进, 形成较好的设计思想
    - 根据原型系统设计出完整, 准确, 一致, 可靠的最终系统
    - 废弃原型系统
  - 追加策略
    - 先构建一个原型系统(功能简单, 性能不高), 作为最终系统的核心
    - 不断进行扩充修改, 加新功能, 发展为最终系统
    - 快速原型
- 适用于
  - 不适合大型软件
  - 对所开发项目的需求理解较差的时候
  - 早期的需求不明确, 后期需求变化大

### 敏捷模型

[scrum](https://www.bilibili.com/video/av35215548)

# 可行性

## 可行性研究

> 以最小的代价在尽可能短的时间内确定问题是否能被解决。

- 技术可行性
- 经济可行性
- 操作可行性
  - 分析系统运行方式, 操作规程在用户组织内能否有效, 顺利实现
  - 工作流程是否人性化, 是否便于使用
- 社会可行性
  - 市场政策
    - 供求预测, 竞争力分析, 价格分析, 定位, 营销策略
  - 法律
    - 版权

## 效益估计

例题: 现投资20万, 从第一年起每年收入4.2万, 生命周期5年, 问是否值得投资

$F = (1+i)^n$
$p$: 初始投资

$i$: 年利率

### 货币的时间价值

> 同样数量的货币随时间的不同具体有不同的价值

投资额 = $200 000*(1+3\%)^5 = 231 855$
收入 = $42000*[(1+3\%)^4 + (1+3\%)^3+(1+3\%)^2+(1+3\%)^1+1] = 222984$

所以不值得

### 纯收入

> 在整个生命周期之内系统的累计经济效益 (折合成现在值) 与投资之差

纯收入 = 折合现价的总收入 - 当前投资额

​			 = $4200*(\frac{1}{1.03^5} + \frac{1}{1.03^4} +\frac{1}{1.03^3} +\frac{1}{1.03^2} +\frac{1}{1.03}) - 200000$

​			 =$-7652$

### 投资回收期

> 工程的累计经济效益等于最初的投资所需的时间

# 需求工程

> 应用已正式有效的技术, 方法进行需求分析, **确定客户的需求**
>
> 帮助分析人员**理解问题**, **定义目标系统的所有外部特征**的一门学科

- 背景: 人们逐渐认识到需求分析活动关系到软件的成功与否, 不仅在软件开发的初期, 而是贯穿整个生命周期

- 优点

  - 是**估算成本和进度**的基础
  - 理解问题, 了解目标系统的外部特征
  - 提高了软件的**开发效率** 
  - 降低软件的**开发和维护成本**, 促进软件工程的发展
  - 为系统验收测试提供了标准

- 内容

  - 需求**开发**

    > 导出, 确认, 维护需求文档

    - 需求**获取**
    - 需求**分析与建模**
    - 编写**需求规格说明书**
    - 需求**评审**

  - 需求**管理**

    > 获取, 记录, 组织, 跟踪系统需求变更
    >
    > 并使客户和项目团队在系统需求变更上保持一致

    - 需求**变更控制**
    - 需求**版本控制**
    - 需求**跟踪**
    - 需求**状态跟踪**

# 结构化分析

> 经典的面向数据流的需求分析方法

- 使用数据流图和数据字典来描述

- 基本思想!
  - 核心思想: **问题分解和抽象**
  - 把信息加工和处理看成**黑盒**, 关注输入输出数据流
  - 自顶向下将黑盒的内容进行细分, **逐层分解**
  - 通过**数据字典**精确确定数据流图中每个数据流的成分

# 面向对象

## 为什么用!

- 结构化软件工程的特点

  - **面向功能分解问题**
  - 软件**重用性**差: 对具体功能应用环境依赖性较高
  - 软件**可维护性**差
    - 早期对系统边界的定义限制了到后期的扩充和修改, 维护困难
    - 由于前提: 上层模块控制下层模块, 所以底层模块变动时, 就必须改变一系列上层模块
  - 软件难以满足**用户需求**
    - 将客观事物转成数据流和加工, 转化造成偏差

- 面向对象方法的优点

  - **符合人们对问题的认识习惯**

    - 是对客观世界实体的抽象, 继承, 聚集, 耦合如实反映事物的关系

  - 增强问题域与最终软件系统之间的衔接

    > 问题域是指被开发系统的应用领域，即在客观世界中由该系统处理的业务范围

    - 开发过程的各个阶段的**概念和表示法是一致的**, 与问题域也一致
    - 由于设计, 模型和程序的主要成分严格对应, 有利于工具自动生成程序的框架和部分代码

  - 易于维护和复用

    - 继承机制, 便于修改扩充, 只要派生新类, 不用修改原代码
    - 封装和继承, 提高对象的内聚性

  - 易于开发大型软件产品

    - 大化小
  
- 面向对象的缺点

  - 学习成本高, 难掌握
  - 难用一些

## 基本概念

### 对象

> 将客观世界的实体抽象为问题空间中的对象
>
> 属性描述静态特征
>
> 操作描述动态特征

### 类

> 具有相同特征和行为的属性归在一起就形成了类
>
> 是对象的抽象

### 消息

> 要实现对象类之间的通信和任务传递, 就用消息传递

### 封装

> 把对象属性和方法结合在一起, 构成独立的单元, 对外界隐藏内部信息
>
> 外界只能通过**接口**与对象发生联系

- 体现了**信息隐蔽**和**局部化**原则

### 继承

> 子类自动拥有父类的全部属性和操作

### 多态

> 在类的不同层次中可以共享一个对象的名字, 但是实现不同

## 设计原则

### 单一职责原则

> Single-Responsibility Principle, SRP
>
> 要求系统中的一个具体设计元素(类)**只完成某一类功能**(职责), 避免在同一个类中完成多个不同的功能

- 为了提高类的内聚度

### 开放-封闭原则
> Open Closed Principle, OCP
>
> **Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.**
>
> 软件实体类(类, 模块, 函数 .etc)应对扩展开放，但对修改封闭

- OCP基本思想: 不能修改原有类就扩展一个类的行为
- 通过增加代码来变化, 而不是通过更改现有代码来变化

### Liskov替换原则

> Liskov Substitution Principle, LSP
>
> 子类应当可以替换父类并出现在父类能够出现的任何地方

- LSP强调了抽象化的具体规范
- 类库中的类的扩展变化并不影响客户端类, 因此在进行面向对象设计时, 针对类的操作行为存在多种变化的情况下, 尽量定义抽象类来为客户端类提供服务, 将操作行为的具体实现延迟到运行时刻绑定
- 类A调用类B的操作method, 类C是类B的子类, C可以替换B的实例, 完成method, 对类A来说, 这个替换是透明的
- 继承关系是针对类型而言的, 即就行为功能而言, 行为功能不是内在的, 私有的, 而是外在的公开的, 是客户类所依赖的
- 所有子类的行为功能必须和客户类对其父类所期望的行为功能保持一致

### 接口隔离原则

> Interface Segregation Principle, ISP
>
> 采用多个与特定客户类相关的接口比采用一个通用的涵盖多个业务方法的接口更好

- 遵循ISP, 使用者就**不用依赖于它们并不需要的方法**
- 对于接口的设计, 应该**保证实现该接口的实例对象只呈现为单一的角色**
  - 当客户程序的要求发生变化而修改接口时, 就不会影响到其他客户程序

### 依赖倒置原则

> Dependence Inversion Principle, DIP
>
> 应用系统中的高层模块不应该依赖于底层模块, 二者都应该依赖于抽象

- 抽象细节不应该依赖于细节实现, 实现细节应该依赖于抽象
- 如果高层模块依赖于底层模块
  - 高层模块的**重用**会变得困难
  - 底层模块的**改变**会波及高层

# 软件概要设计!

## 模块化和模块独立性

> 模块功能单一, 和其他模块没有太多联系

### 模块化

> 将复杂问题自顶向下划分成若干模块, 降低软件复杂性

### 模块独立性

#### 内聚

> 模块功能强度(一个**模块内部**各个元素彼此结合的紧密程度)的度量

- 只做一件事

  

  (下面的排序从上往下内聚程度下降)

- 高内聚

  - **功能内聚**: 一个模块中各个部分都是为完成某一项功能协同工作, 紧密联系, 不可分割
  - 顺序内聚: 一个模块内处理元素和同一个功能密切相关, 而且这些处理元素必须依顺序执行

- 中内聚

  - 通信内聚: 一个模块中个功能部分都是用了相同的输入数据, 或产生了相同的输出数据
  - 过程内聚: 模块内各个组成部分的处理动作各不相同, 彼此相关, 并且受统一控制流支配, 必须按特定的次序执行 (将流程图中的一部分划出来就是了)

- 低内聚: 不能用

  - 时间内聚: 模块在同一时间执行
  - 逻辑内聚: 一个模块完成的多个任务属于相同或类似的类
  - 巧合内聚: 一个模块由若干毫无关系或关系不大的功能的元素偶然组合在一起

#### 耦合

> **模块之间**的相对独立性(互相连接的紧密程度)的度量

​		(下面的排序从上往下耦合程度下降)

- 强耦合
  - 内容耦合
    - 一个模块直接访问另一个模块的内部数据
    - 一个模块不通过正常入口转到另一个模块
    - 两个模块的一部分程序代码重合
    - 一个模块多个入口
  - 公共耦合
    - 一组模块都访问同一公共数据环境
    - 前面模块对公共数据的读写出错导致后面的全错, 且不好定位错误源
  - **外部耦合**: 一组模块都访问同一全局简单变量而不是同一全局数据结构, 而且不通过参数表传递该全局变量的信息
- 中耦合
  - 控制耦合
    - 一个模块通过传送开关, 标志, 名称等控制信息, 明显地控制选择另一模块的功能
    - 被控制模块的修改会影响到控制模块
    - 控制模块要知道被控制模块内部的一些逻辑关系, 这意味着模块的独立性降低
- 低耦合
  - **标记耦合**
    - 一个模块通过参数表传递记录信息
    - **共享了某一数据结构**的子结构而不是简单变量
  - **数据耦合**: 一个模块访问了另一个模块, 彼此之间是通过简单数据参数 (不是控制参数, 公共数据结构或外部变量) 来交换输入, 输出信息
  - **非直接耦合**: 两个模块之间没有直接关系, 它们之间的联系完全是通过主模块的控制和调用来实现的

## 抽象和逐步求精

### 抽象

> 将事物的**共性**集中和概括起来, 暂时**忽略它们之间的差异**
>
> 抽出事物的本质性质而暂时**不考虑它们的细节**

- 对求解问题模块化时可以进行多层次抽象
  - 最高层: 使用问题环境语言概括描述问题解法
  - 较低层: 用过程化方法, 把面向问题的术语和面向实现的术语结合起来描述问题解法
  - 最低层: 直接实现
- 软件工程的每个步骤就是对软件解决方案抽象化程度的一次细化

### 逐步求精

> 自顶向下的设计策略

- 迭代?
- 求精是细化的过程: 细化原始陈述, 不断求精逐步提供越来越多细节
- 抽象和求精是一对互补的概念
  - 抽象说明了过程和数据, 但忽略了底层细节
  - 逐步求精 逐步**揭示底层细节**



## 信息隐藏

> 模块中所包含的信息(包括数据和过程)**不允许其他不需要这些信息的模块使用**

- 模块应该设计得使其所含信息 (过程和数据) 对于那些不需要这些信息的模块不可访问
- 模块之间仅仅交换那些为完成系统功能必须交换的信息

# 设计模式

>   被用来在特定场合下解决一般设计问题的类和相互通信的对象的描述
>
>   对特定问题的描述或解决方法
>
>   套用以往开发过程中, 遇到的相似的问题时的解决方法

## 用处

- 优化的设计经验: 经验总结出来的
- 极高的**复用性**: 复用成功的设计, 提高姿势:laughing:水平
- 丰富的表达能力: 通过提供某些类和对象的相互作用关系以及它们之间潜在联系的说明规范, 设计模式能够提高已有系统的文档管理和系统维护的有效性
- **极低的耦合度**: 设计模式的基本思想就是将程序中可能变化的部分于不变的部分分离, 尽量减少对象之间的耦合

## 工厂模式

[link](https://www.runoob.com/design-pattern/factory-pattern.html)

> 创建对象时不会对客户端暴露创建逻辑, 并且时通过使用一个共同给接口来指向新创建的对象

- 定义一个创建对象的接口, 让其子类自己决定实例化哪一个工厂类, 工厂模式将其创建过程延迟到子类进行
- 

## 抽象工厂模式

> 超级工厂创建其他工厂

## 适配器模式

## 策略模式

## 外观模式

# UML

> unified modeling language
>
> 用面向对象的方式来描述任何类型的系统

## 种类

- 静态结构: 类图, 对象图
- 动态行为: 状态图, 序列图, 顺序图, 通信图, 活动图
- 功能: 用例图

### 用例图

用例描述

| **用例名称** |                    |
| ------------ | ------------------ |
| **用例介绍** |                    |
| **参与者**   |                    |
| **前置条件** |                    |
| **事件流**   | 基本路径, 可选路径 |
| **后置条件** |                    |



## 用途

- 需求分析阶段
  - 用用例捕获**用户需求**
  - **识别主要概念** (抽象, 类, 对象) 和他们之间的关系
- 分析阶段
  - 只对问题域的对象**建模**, 不定义技术细节的类 (接口, 数据库 .etc)
- 设计阶段
  - **理解和分析系统结构** (过早考虑编码不利于建立简单正确的模型)
- 测试阶段
  - 单元测试用 类图 和 类规格说明
  - 集成测试用 部件图 和 合作图
  - 系统测试用 用例图

## 关系

- 聚合, 空心
- 组合, 实心![UML类图](all.assets/UML%E7%B1%BB%E5%9B%BE-1578472820687.jpg)

# 用户界面设计

## 设计原则

- 置于用户的**控制**之下
  - 交互灵活
  - 允许用用户能够撤销或中断交互
  - 将用户于技术细节隔离开
- 减轻用户的**记忆**负担
  - 减少对短期记忆的要求
  - 建立有意识的默认
- 保持**界面**一致
  - 一组应用系统都应实现相同的设计规范

# 软件实现

## 目标

> 选择某种程序设计语言, 将详细设计结构进行编码实现, 并形成可执行的软件系统的过程

## 任务

1. 程序设计**语言**的选择
2. 集成开发**环境**的选择
3. 程序实现**算法**的设计: 针对要实现特定功能的程序模块
4. 程序**编码**实现: 包括测试, 发现并改正错误, 输出正确的可执行程序

# 软件测试

## 目的

用**人工**或**自动**手段来运行或测试系统, 发现**是否有问题**, **是否满足规定的需求**, 弄清预期结果和实际结果之间的差距

## 概念

- 测试时为了发现缺陷而执行程序的过程
- 一个好的测试, 一个好的测试用例能找到之前没有发现的缺陷

## 基本认识

- **不**可能**完全测试程序**
- **不**能**证明软件是完全正确的**
- **不**是**所有软件缺陷都要修复**
- 软件测试是**有风险**的: 运行环境不同导致测试结果不同, 需求改动, 质量标准不明确
- 找到的缺陷越多, 说明软件本身的缺陷越多
- 有时软件缺陷对测试有免疫力
- 产品说明书经常变化

## 技术

- 静态测试

  > 静态检查和审核

- 动态测试

  > 使用和运行软件

- **黑盒测试**

  > 功能性测试, 行为测试
  >
  > 完全**不考虑程序的内部结构和处理过程,** 只知道软件的每个功能是否正常运行

  - 静态黑盒测试: 测试产品说明书
  - 动态黑盒测试
    - 数据测试: 边界值, 次边界值(ASCII表), 空值, 零值, 错误值
    - 状态测试: 测试状态转换

- **白盒测试**

  > 透明盒测试
  >
  > 知道软件内部工作过程, 通过测试检测软件内部动作是否按照**产品规格说明**的规定正常运行

  - 静态白盒测试
    - 正式审查
    - 编码标准和规范
    - 通用代码审查清单
  - 动态白盒测试
    - 分段测试: 定位问题区间
    - 数据覆盖: 检查数据的中间值, 而不仅仅值最终状态, 公式等式, 错误强制(强制赋错误值)
    - 代码覆盖: 

## 策略

- **单元测试:** 对软件的最小单元程序模块进行测试
- **集成测试**
  - 按一定策略对单元测试的模块进行**组装**
  - 看模块组件**接口连接**有没问题
- **确认测试**: **用户参加**的测试, 黑盒测试
- 系统测试: 测试软件安装到实际应用的系统中后, 能否与系统的其余部分协调工作

## 面向对象的测试类型

- 模型测试
- 类测试
- 交互测试: 类进行联合测试
- 系统(子系统)测试
- 验收测试
- 发布测试

# 软件调试

> 确定程序中可疑缺陷的确切性质和位置, 对程序的设计和编码进行修改, 纠正

# 软件维护

成本是整个软件生存周期成本的40%~70%, 花费最多

## 分类

- 完善性维护 **50%**
  - 满足用户对软件新的功能和性能需求
  - 对原有软件的修改和扩充

- 适应性维护 **25%**
  - 适应新的硬件软件环境, 修改数据库
- 改正(纠错)性维护 **20%**
  - 修复隐藏错误
- 预防性维护 **5%**
  - 提高软件的可维护性, 可靠性

## 成本

- 生产性活动
  - 分析评价
  - 修改设计
  - 编写程序代码
- 非生产性活动
  - 理解程序代码功能
  - 解释数据结构, 接口特点, 设计约束
